:: MapTesting [#map nostats]
<<set $GameState = "map">>
<<run $('#map').removeClass('hidden');>>
<<run $('.canvas-container').removeClass('hidden');>>

<<done>>
<<script>>
    let sv = State.variables;

    /* For zoom/resize detection */
    let px_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;

    /* TODO add callback to resize canvas. */
    function isZooming() {
        var newPx_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;
        if (newPx_ratio !== px_ratio) {
            px_ratio = newPx_ratio;
            /* console.log("zooming"); */
            return true;
        } else {
            /* console.log("just resizing"); */
            return false;
        }
    }

    $(window).resize(function() {
        isZooming();
    });

    /** 
     * "Grid Fidelity" 
     * The distance, in px, between the lines in the grid.
     * 
     * 3.125% is 32 grid boxes along the greater length.  
     */
    const gF = window.outerWidth >= window.outerHeight ? (window.outerWidth * .03125) : (window.outerHeight * .03125);

    /** Returns the top + left intersection in number of fidelity units. */
    /* TODO: Refactor into obj with x and y fields to match native fabric.js objects. */
    function getGFCoords(pos, fidelity = gF) {
        return [
            (pos[0] - (pos[0] % fidelity)) / fidelity,
            (pos[1] - (pos[1] % fidelity)) / fidelity
        ];
    }

    /** Determine if player is interacting with any interactables. */
    function isPlayerIntersecting(player) {
        sv.canvas.interactableGroup.forEachObject((obj) => {
            if (getGFCoords([player.aCoords.tl.x, player.aCoords.tl.y]).toString() === getGFCoords([obj.aCoords.tl.x, obj.aCoords.tl.y]).toString()) {
                obj.timesVisited += 1;
                obj.intersecting();
            }
        });
    }

    /** Setup fabric Canvas. */
    /* http://fabricjs.com/articles/ */
    sv.canvas = new fabric.Canvas('map', {
        width: window.outerWidth,
        height: window.outerHeight,
        backgroundColor: 'rbg(0,0,0)',
        selection: false,
    });
    sv.canvas.setDimensions({
        width: 1280,
        height: 720
    }, {
        cssOnly: true
    });
    sv.canvas.gF = gF; /* So that we can use gF in the Interactable class. */

    /* Update element css to what we need. */
    setup.fns.waitForElm('.canvas-container').then(() => {
        $('.canvas-container').css('position', 'unset');
    });

    /** DEBUG FEATURE: Grid lines. */
    if (true) {
        /* Initialize Grid Group */
        let gridGroup = new fabric.Group();

        /* Draw Vertical Lines */
        for (let i = 0; i <= (window.outerWidth / gF); i++) {
            let temp = new fabric.Line([(gF * i), 0, (gF * i), window.outerHeight, ], {
                stroke: 'rgb(80,80,80)',
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                moveCursor: 'default',
                hoverCursor: 'defaut',
                selectable: false,
            });

            sv.canvas.add(temp);
            gridGroup.add(temp);
        }

        /* Draw Horizontal Lines */
        for (let i = 0; i <= (window.outerHeight / gF); i++) {
            let temp = new fabric.Line([0, (gF * i), window.outerWidth, (gF * i), ], {
                stroke: 'rgb(80,80,80)',
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                moveCursor: 'default',
                hoverCursor: 'defaut',
                selectable: false,
            });

            sv.canvas.add(temp);
            gridGroup.add(temp);
        }
    }

    /**
     * Interactables
     * 
     * It is a bit unintuitive, but Interactables are added to the 
     * interactableGroup by default, so we don't need to assign these 
     * as variables.
     */

    /* Initialize Interactable Group */
    sv.canvas.interactableGroup = new fabric.Group();
    
    new setup.map.Interactable('project/imported_assets/img/png/turn_icon_en.png', { 
        top: gF * 3,
        left: gF * 3,
        intersecting: function() {
            $('.canvas-container').addClass('hidden');
            sv.canvas = undefined;

            State.variables.ci = new setup.COM.CombatInstance({
			winPassage: "MapTesting",
			losePassage: "MapTesting",
                ep: [
                    "EN_BABY_SPIDER",
                    "EN_MOMMY_SPIDER",
                    "EN_BABY_SPIDER",
                    "EN_BABY_SPIDER",
                    "EN_BABY_SPIDER",
                ],
            });

            Engine.play("Combat_Overlord");
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: gF * 4,
        left: gF * 4,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb1);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: gF * 8,
        left: gF * 12,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb2);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: gF * 6,
        left: gF * 22,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb3);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: gF * 15,
        left: gF * 21,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb4);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/init_icon_pl.png', {
        top: gF * 15,
        left: gF * 15,
        intersecting: function() {
            setup.tb.citymenutesting.display();
        },
    });

    /* Initialize Player Group */
    sv.canvas.playerGroup = new fabric.Group();

    /* Stand in for the player.*/
    new setup.map.Interactable('project/imported_assets/img/png/turn_icon_pl.png', { 
        top: gF * 18,
        left: gF * 6,
        interactable: false,
        player: true,
    });

    /* Pathfinding for player. */
    sv.canvas.on('mouse:down', function(options) {
        if (sv.GameState === "map") {
            let player = sv.canvas.playerGroup.getObjects()[0];

            fabric.runningAnimations.cancelByTarget(player);
            fabric.runningAnimations.cancelAll();

            let oldCoords = getGFCoords([player.aCoords.tl.x, player.aCoords.tl.y]);
            let newCoords = getGFCoords([options.e.clientX, options.e.clientY]);

            /* Don't do anything if user clicks the GF box the player is in. */
            if (oldCoords.toString() === newCoords.toString()) {
                return;
            }

            let horiDuration = Math.abs(newCoords[0] - oldCoords[0]) * 150;
            let vertiDuration = Math.abs(newCoords[1] - oldCoords[1]) * 150;

            player.animate('left', newCoords[0] * gF, {
                onChange: sv.canvas.renderAll.bind(sv.canvas),
                duration: horiDuration,
                easing: null,
            });
            player.animate('top', newCoords[1] * gF, {
                onChange: sv.canvas.renderAll.bind(sv.canvas),
                duration: vertiDuration,
                easing: null,
            });

            /* Angle doesn't matter. In reality, I only want the onComplete handler to run when both left and top animations are finished. So I set the duration of this animate to be equal to the longer duration. This means it gets run when the longer duration is finished. */
            player.animate('angle', 0, {
                duration: horiDuration >= vertiDuration ? horiDuration : vertiDuration,
                onComplete: function() {
                    isPlayerIntersecting(player);
                },
            });
        }
    });
<</script>>
<</done>>

/**
    Box Based Coordinate System
        If Box has encounter, save position and load encounter.
            Create interactable class.
            ☐ Combat
                Go to already completed combat interface. Reward screen should return to map.
            ☐ City
                Open city screen as a dialog-esque screen. Implement via widget to dynamically load city data from JSON. This should probably be HTML elements overlaid on the map.
            ☑ TextBox
            ☐ Item Get
 */



:: MapTestingTextBoxArr [.helper script]
/* NOTE: I don't actually want this to run until the map calls for it, tbh. */
const redrecttb1 = {
    lines: [{
            line: "No portrait here!",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb2 = {
    showPortrait: true,
    lines: [{
            line: "The portrait should be showing here.",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb3 = {
    showSpeakerName: true,
    showPortrait: true,
    lines: [{
            line: "An unknown speaker should be here.",
        },
        {
            portrait: "project/imported_assets/img/png/turn_icon_pl.png",
            speaker: "redrect3",
            line: "The portrait and name should be showing here.",
        },
        {
            line: "The same name should sitll be here",
        },
        {
            portrait: "project/imported_assets/img/png/turn_icon.png",
            speaker: "new name",
            line: "A new name should now appear.",
        },
    ],
};

const redrecttb4 = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "background image testing.",
    }, ],
};

const tarverntb = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "We've at the tavern!",
    },],
};

const gatherinfotb = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "We're gathering info!",
    },],
};

const citymenutesting = new setup.map.CityMenu({
    name: "Testing City c:",
    hasGuildHall: true,

    hasInn: true,
    innHandler: function(menu) {
        
    },

    hasGatherInfo: true,
    gatherInfoHandler: function(menu) {
        new setup.tb.TextBox(setup.tb.gatherinfotb);
    },
    hasTavern: true,
    tavernHandler: function(menu) {
        new setup.tb.TextBox(setup.tb.tarverntb);
    },
});

(function(S) {
    if (!S.tb) {
        S.tb = {};
    }

    S.tb.redrecttb1 = redrecttb1;
    S.tb.redrecttb2 = redrecttb2;
    S.tb.redrecttb3 = redrecttb3;
    S.tb.redrecttb4 = redrecttb4;
    setup.tb.gatherinfotb = gatherinfotb;
    S.tb.tarverntb = tarverntb;
    S.tb.citymenutesting = citymenutesting;
})(setup);
