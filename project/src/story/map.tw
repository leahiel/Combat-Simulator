:: MapTesting [#map nostats]
<<set $GameState = "map">>

<<done>>
<<script>>
    let sv = State.variables;

    /** Setup fabric Canvas. */
    /* http://fabricjs.com/articles/ */
    sv.map = new setup.map.Map();

    /**
     * Interactables
     * 
     * It is a bit unintuitive, but Interactables are added to the 
     * interactableGroup by default, so we don't need to assign these 
     * as variables.
     */
    
    new setup.map.Interactable('project/imported_assets/img/png/turn_icon_en.png', { 
        top: sv.map.gF * 3,
        left: sv.map.gF * 3,
        intersecting: function() {
            $('.canvas-container').addClass('hidden');
            sv.map = undefined;

            State.variables.ci = new setup.COM.CombatInstance({
			winPassage: "MapTesting",
			losePassage: "MapTesting",
                ep: [
                    "EN_BABY_SPIDER",
                    "EN_MOMMY_SPIDER",
                    "EN_BABY_SPIDER",
                    "EN_BABY_SPIDER",
                    "EN_BABY_SPIDER",
                ],
            });

            Engine.play("Combat_Overlord");
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: sv.map.gF * 4,
        left: sv.map.gF * 4,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb1);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: sv.map.gF * 8,
        left: sv.map.gF * 12,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb2);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: sv.map.gF * 6,
        left: sv.map.gF * 22,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb3);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/turn_icon.png', { 
        top: sv.map.gF * 15,
        left: sv.map.gF * 21,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb4);
        },
    });

    new setup.map.Interactable('project/imported_assets/img/png/init_icon_pl.png', {
        top: sv.map.gF * 15,
        left: sv.map.gF * 15,
        intersecting: function() {
            setup.tb.citymenutesting.display();
        },
    });

    /* Stand in for the player.*/
    new setup.map.Interactable('project/imported_assets/img/png/turn_icon_pl.png', { 
        top: sv.map.gF * 18,
        left: sv.map.gF * 6,
        interactable: false,
        player: true,
    });
<</script>>
<</done>>

/**
    Box Based Coordinate System
        If Box has encounter, save position and load encounter.
            Create interactable class.
            ☐ Combat
                Go to already completed combat interface. Reward screen should return to map.
            ☐ City
                Open city screen as a dialog-esque screen. Implement via widget to dynamically load city data from JSON. This should probably be HTML elements overlaid on the map.
            ☑ TextBox
            ☐ Item Get
 */



:: MapTestingTextBoxArr [.helper script]
/* NOTE: I don't actually want this to run until the map calls for it, tbh. */
const redrecttb1 = {
    lines: [{
            line: "No portrait here!",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb2 = {
    showPortrait: true,
    lines: [{
            line: "The portrait should be showing here.",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb3 = {
    showSpeakerName: true,
    showPortrait: true,
    lines: [{
            line: "An unknown speaker should be here.",
        },
        {
            portrait: "project/imported_assets/img/png/turn_icon_pl.png",
            speaker: "redrect3",
            line: "The portrait and name should be showing here.",
        },
        {
            line: "The same name should sitll be here",
        },
        {
            portrait: "project/imported_assets/img/png/turn_icon.png",
            speaker: "new name",
            line: "A new name should now appear.",
        },
    ],
};

const redrecttb4 = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "background image testing.",
    }, ],
};

const tarverntb = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "We've at the tavern!",
    },],
};

const gatherinfotb = {
    showBackground: true,
    backgroundSrc: "project/imported_assets/img/png/tavern1.png",
    lines: [{
        line: "We're gathering info!",
    },],
};

const citymenutesting = new setup.map.CityMenu({
    name: "Testing City c:",
    hasGuildHall: true,

    hasInn: true,
    innHandler: function(menu) {
        
    },

    hasGatherInfo: true,
    gatherInfoHandler: function(menu) {
        new setup.tb.TextBox(setup.tb.gatherinfotb);
    },
    hasTavern: true,
    tavernHandler: function(menu) {
        new setup.tb.TextBox(setup.tb.tarverntb);
    },
});

(function(S) {
    if (!S.tb) {
        S.tb = {};
    }

    S.tb.redrecttb1 = redrecttb1;
    S.tb.redrecttb2 = redrecttb2;
    S.tb.redrecttb3 = redrecttb3;
    S.tb.redrecttb4 = redrecttb4;
    setup.tb.gatherinfotb = gatherinfotb;
    S.tb.tarverntb = tarverntb;
    S.tb.citymenutesting = citymenutesting;
})(setup);


:: Resizing
/* I don't know where to put this yet, but it's for resizing the map. */

/* For zoom/resize detection */
let px_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;

/* TODO add callback to resize canvas. */
function isZooming() {
    var newPx_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;
    if (newPx_ratio !== px_ratio) {
        px_ratio = newPx_ratio;
        /* console.log("zooming"); */
        return true;
    } else {
        /* console.log("just resizing"); */
        return false;
    }
}

$(window).resize(function() {
    isZooming();
});
