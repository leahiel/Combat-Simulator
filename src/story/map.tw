:: MapTesting [#map]
<<set $GameState = "map">>
/* TODO: If canvas already exists, don't make it again. */
<canvas id="map"></canvas>

<<done>>
<<script>>
    /* For zoom/resize detection */
    let px_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;

    $(window).resize(function() {
        isZooming();
    });

    /* TODO add callback function to resize canvas. */
    function isZooming() {
        var newPx_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;
        if (newPx_ratio !== px_ratio) {
            px_ratio = newPx_ratio;
            /* console.log("zooming"); */
            return true;
        } else {
            /* console.log("just resizing"); */
            return false;
        }
    }

    /** "Grid Fidelity" The distance, in px, between the lines in the grid. */
    const gF = window.outerWidth * .02;

    /** Returns the top + left intersection in number of fidelity units.*/
    function getGFCoords(pos, fidelity = gF) {
        return [
            (pos[0] - (pos[0] % fidelity)) / fidelity, 
            (pos[1] - (pos[1] % fidelity)) / fidelity
        ];
    }

    /** Setup fabric Canvas. */
    /* http://fabricjs.com/articles/ */
    const canvas = new fabric.Canvas('map', {
        width: window.outerWidth,
        height: window.outerHeight,
        backgroundColor: 'rbg(0,0,0)',
        selection: false,
    });
    canvas.setDimensions({
        width: 1280,
        height: 720
    }, {
        cssOnly: true
    });

    /* Put canvas element where it belongs */
    setup.fns.waitForElm('.canvas-container').then(() => {
        $('.canvas-container').prependTo('html');
    });

    /* Prep Grid Group */
    let gridGroup = new fabric.Group();

    /* Draw Vertical Lines */
    for (let i = 0; i <= (window.outerWidth / gF); i++) {
        let temp =  new fabric.Line([(gF * i), 0, (gF * i), window.outerHeight,], {
            stroke: 'rgb(80,80,80)',
            hasControls: false,
            hasBorders: false,
            lockMovementX: true,
            lockMovementY: true,
            lockRotation: true,
            moveCursor: 'default',
            hoverCursor: 'defaut',
            selectable: false,
        });

        canvas.add(temp);
        gridGroup.add(temp);
    }

    /* Draw Horizontal Lines */
    for (let i = 0; i <= (window.outerHeight / gF); i++) {
        let temp =  new fabric.Line([0, (gF * i), window.outerWidth, (gF * i),], {
            stroke: 'rgb(80,80,80)',
            hasControls: false,
            hasBorders: false,
            lockMovementX: true,
            lockMovementY: true,
            lockRotation: true,
            moveCursor: 'default',
            hoverCursor: 'defaut',
            selectable: false,
        });

        canvas.add(temp);
        gridGroup.add(temp);
    }


    /* Stand in for the player. */
    const bluetri1 = new fabric.Triangle({
        top: 0,
        left: 0,
        width: gF,
        height: gF,
        fill: 'blue',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'defaut',
        selectable: false,
    });
    canvas.add(bluetri1);

    /* Prep Interactable Group */
    let interactableGroup = new fabric.Group();

    /* Stand in for the interactables. */
    const redrect1 = new fabric.Rect({
        top: gF * 4,
        left: gF * 4,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'defaut',
        selectable: false,
        intersecting: function() {
            Dialog.setup(`redrect1`);
            Dialog.wiki('redrect1');
            Dialog.open();
        },
    });
    canvas.add(redrect1);
    interactableGroup.add(redrect1);

    const redrect2 = new fabric.Rect({
        top: gF * 8,
        left: gF * 12,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'defaut',
        selectable: false,
        intersecting: function() {
            Dialog.setup(`redrect2`);
            Dialog.wiki('redrect2');
            Dialog.open();
        },
    });
    canvas.add(redrect2);
    interactableGroup.add(redrect2);

    const redrect3 = new fabric.Rect({
        top: gF * 6,
        left: gF * 22,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'defaut',
        selectable: false,
        intersecting: function() {
            Dialog.setup(`redrect3`);
            Dialog.wiki('redrect3');
            Dialog.open();
        },
    });
    canvas.add(redrect3);
    interactableGroup.add(redrect3);

    function isPlayerIntersecting (player) {
        interactableGroup.forEachObject((obj) => {
            if (getGFCoords([bluetri1.aCoords.tl.x, bluetri1.aCoords.tl.y]).toString() === getGFCoords([obj.aCoords.tl.x, obj.aCoords.tl.y]).toString()) {
                obj.intersecting();
            }
        });
    }


    /* On mousedown, I want to return the closest [top, left] intersection. */
    canvas.on('mouse:down', function(options) {
        fabric.runningAnimations.cancelByTarget(bluetri1);
        fabric.runningAnimations.cancelAll();

        let oldCoords = getGFCoords([bluetri1.aCoords.tl.x, bluetri1.aCoords.tl.y]);
        let newCoords = getGFCoords([options.e.clientX, options.e.clientY]);
        let horiDuration = Math.abs(newCoords[0] - oldCoords[0]) * 100;
        let vertiDuration = Math.abs(newCoords[1] - oldCoords[1]) * 100;

        bluetri1.animate('left', newCoords[0] * gF, {
            onChange: canvas.renderAll.bind(canvas),
            duration: horiDuration,
            easing: null,
        });
        bluetri1.animate('top', newCoords[1] * gF, {
            onChange: canvas.renderAll.bind(canvas),
            duration: vertiDuration,
            easing: null,
        });
        bluetri1.animate('angle', 0, {
            duration: horiDuration >= vertiDuration ? horiDuration : vertiDuration,
            onComplete: function() {
                isPlayerIntersecting (bluetri1);
            },
        });


    });
<</script>>
<</done>>



/**
    Box Based Coordinate System
        If user clicks in Box:
            Sets Pathfinding to center of box.
            Then Moves character diagonally first at 1:1 x/y ratio.
            Then Moves character horizontally/vertically.

        If Box has encounter, save position and load encounter.
            re: City
                Open city screen as a dialog-esque screen. Implement via widget to dynamically load city data from JSON. This should probably be HTML elements overlaid on the map.
            re: Combat
                Go to already completed combat interface. Reward screen should return to map. In order to prevent re-rendering of the map, pin it to $(html) and hide it during combat, and return it back to normal. The cost should be minimal enough even on phones, but rendering it is expected to take half a second, so benefit should be worthwhile.
            re: Talkbox
                Open up as-of-yet-planned talkbox. This should probably be HTML elements overlaid on the map.
            re: Item Get:
                Process retrieving a material. This should probably be HTML elements overlaid on the map.

    Fabric Canvas Implementation:
        Canvas 100vw/vh

 */
