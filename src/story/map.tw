:: MapTesting [#map nostats]
<<set $GameState = "map">>
<<run $('#map').removeClass('hidden');>>
<<run $('.canvas-container').removeClass('hidden');>>

<<done>>
<<script>>
    let sv = State.variables;

    /* For zoom/resize detection */
    let px_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;

    /* TODO add callback to resize canvas. */
    function isZooming() {
        var newPx_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth;
        if (newPx_ratio !== px_ratio) {
            px_ratio = newPx_ratio;
            /* console.log("zooming"); */
            return true;
        } else {
            /* console.log("just resizing"); */
            return false;
        }
    }

    $(window).resize(function() {
        isZooming();
    });

    /** 
     * "Grid Fidelity" 
     * The distance, in px, between the lines in the grid.
     * 
     * 3.125% is 32 grid boxes along the greater length.  
     */
    const gF = window.outerWidth >= window.outerHeight ? (window.outerWidth * .03125) : (window.outerHeight * .03125);

    /** Returns the top + left intersection in number of fidelity units. */
    /* TODO: Refactor into obj with x and y fields to match native fabric.js objects. */
    function getGFCoords(pos, fidelity = gF) {
        return [
            (pos[0] - (pos[0] % fidelity)) / fidelity,
            (pos[1] - (pos[1] % fidelity)) / fidelity
        ];
    }

    /** Determine if player is interacting with any interactables. */
    function isPlayerIntersecting(player) {
        interactableGroup.forEachObject((obj) => {
            if (getGFCoords([bluetri1.aCoords.tl.x, bluetri1.aCoords.tl.y]).toString() === getGFCoords([obj.aCoords.tl.x, obj.aCoords.tl.y]).toString()) {
                obj.intersecting();
            }
        });
    }

    /** Setup fabric Canvas. */
    /* http://fabricjs.com/articles/ */
    const canvas = new fabric.Canvas('map', {
        width: window.outerWidth,
        height: window.outerHeight,
        backgroundColor: 'rbg(0,0,0)',
        selection: false,
    });
    canvas.setDimensions({
        width: 1280,
        height: 720
    }, {
        cssOnly: true
    });

    /* Put canvas element where it belongs. */
    /* REVIEW: Should I just do this in StoryInterface? */
    setup.fns.waitForElm('.canvas-container').then(() => {
        $('.canvas-container').css('position', 'unset');
    });

    /** DEBUG FEATURE: Grid lines. */
    if (true) {
        /* Initialize Grid Group */
        let gridGroup = new fabric.Group();

        /* Draw Vertical Lines */
        for (let i = 0; i <= (window.outerWidth / gF); i++) {
            let temp = new fabric.Line([(gF * i), 0, (gF * i), window.outerHeight, ], {
                stroke: 'rgb(80,80,80)',
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                moveCursor: 'default',
                hoverCursor: 'defaut',
                selectable: false,
            });

            canvas.add(temp);
            gridGroup.add(temp);
        }

        /* Draw Horizontal Lines */
        for (let i = 0; i <= (window.outerHeight / gF); i++) {
            let temp = new fabric.Line([0, (gF * i), window.outerWidth, (gF * i), ], {
                stroke: 'rgb(80,80,80)',
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                moveCursor: 'default',
                hoverCursor: 'defaut',
                selectable: false,
            });

            canvas.add(temp);
            gridGroup.add(temp);
        }
    }

    /* Initialize Interactable Group */
    let interactableGroup = new fabric.Group();

    /* Stand in for the interactables. */
    const img1 = new fabric.Image.fromURL(
        'src/assets/img/png/turn_icon_pl.png', 
        function (img) {
            console.log(img);
            img.setOptions({
                top: gF * 3,
                left: gF * 3,
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockRotation: true,
                moveCursor: 'default',
                hoverCursor: 'default',
                selectable: false,
                intersecting: function() {
                    $('.canvas-container').addClass('hidden');
                    Engine.play("Inbetween");
                },
            });

            if (img.width >= img.height) {
                img.scaleToWidth(gF);
            } else {
                img.scaleToHeight(gF);
            }

            canvas.add(img);
            interactableGroup.add(img);
        }
    );

    const redrect1 = new fabric.Rect({
        top: gF * 4,
        left: gF * 4,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'default',
        selectable: false,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb1);
        },
    });
    canvas.add(redrect1);
    interactableGroup.add(redrect1);

    const redrect2 = new fabric.Rect({
        top: gF * 8,
        left: gF * 12,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'default',
        selectable: false,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb2);
        },
    });
    canvas.add(redrect2);
    interactableGroup.add(redrect2);

    const redrect3 = new fabric.Rect({
        top: gF * 6,
        left: gF * 22,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'default',
        selectable: false,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb3);
        },
    });
    canvas.add(redrect3);
    interactableGroup.add(redrect3);

    const redrect4 = new fabric.Rect({
        top: gF * 15,
        left: gF * 21,
        width: gF,
        height: gF,
        fill: 'red',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'default',
        selectable: false,
        intersecting: function() {
            new setup.tb.TextBox(setup.tb.redrecttb4);
        },
    });
    canvas.add(redrect4);
    interactableGroup.add(redrect4);

    /* Stand in for the player. */
    const bluetri1 = new fabric.Triangle({
        top: 0,
        left: 0,
        width: gF,
        height: gF,
        fill: 'blue',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        moveCursor: 'default',
        hoverCursor: 'defaut',
        selectable: false,
    });
    canvas.add(bluetri1);

    /* Pathfinding for player. */
    canvas.on('mouse:down', function(options) {
        if (sv.GameState === "map") {
            fabric.runningAnimations.cancelByTarget(bluetri1);
            fabric.runningAnimations.cancelAll();

            let oldCoords = getGFCoords([bluetri1.aCoords.tl.x, bluetri1.aCoords.tl.y]);
            let newCoords = getGFCoords([options.e.clientX, options.e.clientY]);

            /* Don't do anything if user clicks the GF box the player is in. */
            if (oldCoords.toString() === newCoords.toString()) {
                return;
            }

            let horiDuration = Math.abs(newCoords[0] - oldCoords[0]) * 80;
            let vertiDuration = Math.abs(newCoords[1] - oldCoords[1]) * 80;

            bluetri1.animate('left', newCoords[0] * gF, {
                onChange: canvas.renderAll.bind(canvas),
                duration: horiDuration,
                easing: null,
            });
            bluetri1.animate('top', newCoords[1] * gF, {
                onChange: canvas.renderAll.bind(canvas),
                duration: vertiDuration,
                easing: null,
            });

            /* Angle doesn't matter. In reality, I only want the onComplete handler to run when both left and top animations are finished. So I set the duration of this animate to be equal to the longer duration. This means it gets run when the longer duration is finished. */
            bluetri1.animate('angle', 0, {
                duration: horiDuration >= vertiDuration ? horiDuration : vertiDuration,
                onComplete: function() {
                    isPlayerIntersecting(bluetri1);
                },
            });
        }
    });
<</script>>
<</done>>



/**
    Box Based Coordinate System
        If user clicks in Box:
            ☑ Sets Pathfinding to center of box.
            ☑ Then Moves character diagonally first at 1:1 x/y ratio.
            ☑ Then Moves character horizontally/vertically.

        If Box has encounter, save position and load encounter.
            Create interactable class.
            ☐ Combat
                Go to already completed combat interface. Reward screen should return to map.
            ☐ City
                Open city screen as a dialog-esque screen. Implement via widget to dynamically load city data from JSON. This should probably be HTML elements overlaid on the map.
            ☑ TextBox
            ☐ Item Get
    Fabric Canvas Implementation:
        ☑ Canvas 100vw/vh  [actually, window.outerWidth and window.outerHeight]
        ☑ overflow: hidden
 */



:: MapTestingTextBoxArr [.helper script]
const redrecttb1 = {
    lines: [{
            line: "No portrait here!",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb2 = {
    showPortrait: true,
    lines: [{
            line: "The portrait should be showing here.",
        },
        {
            line: "String 2",
        },
    ],
};

const redrecttb3 = {
    showSpeakerName: true,
    showPortrait: true,
    lines: [{
            line: "An unknown speaker should be here.",
        },
        {
            portrait: "src/assets/img/png/turn_icon_pl.png",
            speaker: "redrect3",
            line: "The portrait and name should be showing here.",
        },
        {
            line: "The same name should sitll be here",
        },
        {
            portrait: "src/assets/img/png/turn_icon.png",
            speaker: "new name",
            line: "A new name should now appear.",
        },
    ],
};

const redrecttb4 = {
    showBackground: true,
    backgroundSrc: "src/assets/img/png/tavern1.png",
    lines: [{
        line: "background image testing.",
    }, ],
};

(function(S) {
    if (!S.tb) {
        S.tb = {};
    }

    S.tb.redrecttb1 = redrecttb1;
    S.tb.redrecttb2 = redrecttb2;
    S.tb.redrecttb3 = redrecttb3;
    S.tb.redrecttb4 = redrecttb4;
})(setup);

