:: Combat_Overlord [@combatoverlord .combat nostats]
/* This passage will only be run once, and will be the predominant passage until combat is over. This will allow us to keep _vars until we are done with the combat. */
/* <<set _pc to new setup.COM.Combatant(State.variables.Player.Derived)>> */
<<set _pc to {health: 14, healthMax: 14, init: 63, attacks: [setup.COM.attacks.stab]}>> /* NOTE TESTING ONLY */
<<set _pp to [_pc]>> /* For future compatibility, if there are more than one pc. This will NOT be used in this story. */
<<script>>
State.temporary.ep = [];
for (let uninitEnemy of State.variables.ep) {
    State.temporary.ep.push(new setup.COM.Combatant(setup.COM.monsters[uninitEnemy]));
}
<</script>>


/* TODO: These two below should actaully be handled as story variables, before this passage is called. */
<<set _win to "victorypassagename">>
<<set _lose to "losepassagename">>
<<script>>
    $(document).one(":passagedisplay", function() {
        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
    });
<</script>>


<span id="combatZone">
/* This area will be replaced multiple times as the fight progresses. */
/* TODO: Show the statisitical details of all combatants. */
</span>
<br>

<span id="notifArea" style="font-size:2em"></span><br>
<canvas id="initBar" width="2048" height="384"></canvas>
/* Here's the documentation for jCanvas. 
Present me, please say thank you to past me for having forethought for once:
https://projects.calebevans.me/jcanvas/docs/ 
*/
<br>


<span id="playerOptions">
/* This area will change depending on whose turn it is. It will let the player pick attacks, use items, etc, etc. */
/* It gets set in Combat_Zone */
</span>
<br>



:: Combat_Zone [.combat .helper nostats]
<<script>>
function drawCombat(activeChar) {
    $("#combatZone").empty().wiki(Story.get("Combat_Zone_Main").processText());
    $("#playerOptions").empty().wiki(Story.get("Player_Options").processText());


    $('#initBar').clearCanvas();

    /* The rhombus. Yellow if no one has a turn, red if enemy, green if ally. */
    if (activeChar === "pp") {
        $('#initBar').drawImage({
            source: "src/assets/img/png/turn_icon_pl.png",
            x: 192, y: 192,
            width: 384,
            height: 384,
        });
    } else if (activeChar === "ep") {
        $('#initBar').drawImage({
            source: "src/assets/img/png/turn_icon_en.png",
            x: 192, y: 192,
            width: 384,
            height: 384,
        });
    } else {
        $('#initBar').drawImage({
            source: "src/assets/img/png/turn_icon.png",
            x: 192, y: 192,
            width: 384,
            height: 384,
        });
    }

    /* The left most starting position of the horizontal line. */
    let horiBarXPos = 432;

    /* The horizontal line. */
    $('#initBar').drawLine({
        strokeStyle: '#FFFF00',
        strokeWidth: 6,
        rounded: true,
        x1: horiBarXPos, y1: 192,
        x2: 2000, y2: 192,
    });

    /* The player init icon positions. */
    for (let player in State.temporary.pp) {
        if (State.temporary.pp[player].health > 0) {
            let xpos = Math.min(State.temporary.pp[player].init * 8 + horiBarXPos, 2000);

            $('#initBar').drawImage({
                source: "src/assets/img/png/init_icon_pl.png",
                x: xpos, y: 230,
                width: 36,
                height: 48,
            });
        }
    }
    
    /* The enemy init icon positions. */
    for (let enemy in State.temporary.ep) {
        if (State.temporary.ep[enemy].health > 0) {
            let xpos = Math.min(State.temporary.ep[enemy].init * 8 + horiBarXPos, 2000);

            $('#initBar').drawImage({
                source: "src/assets/img/png/init_icon_en.png",
                x: xpos, y: 160,
                width: 36,
                height: 48,
            });
        }
    }
};

State.temporary.pphealth = setup.fns.assignFieldOfObjectsToArray(State.temporary.pp, "health");
State.temporary.ephealth = setup.fns.assignFieldOfObjectsToArray(State.temporary.ep, "health");

if (setup.fns.allValuesTrue(State.temporary.pphealth, function(v) {return v <= 0})) { 
	/* TODO: #notifArea displays <<ibutton>> with _lose */
    drawCombat(null);
    $("#notifArea").empty().wiki("YOU LOSE");

} else if (setup.fns.allValuesTrue(State.temporary.ephealth, function(v) {return v <= 0})) { 
    /* TODO: #notifArea displays <<ibutton>> with _win */
    drawCombat(null);
    $("#notifArea").empty().wiki("YOU WIN");

} else {
    async function processTurns(pp, ep) {
        function waitFor(ms) {
            return new Promise(resolve => {
                setTimeout(() => { resolve('') }, ms);
            });
        };

        let activeCharacter = null;

        /* Check if anyone has a turn available. */
        pp.forEach((char) => {
            if (char.init <= 0 && char.health > 0) {
                activeCharacter = char;
                return;
            }
        });
        if (activeCharacter === null) {
            ep.forEach((char) => {
                if (char.init <= 0 && char.health > 0) {
                    activeCharacter = char;
                    return;
                }
            });
        }

        State.temporary.turn = activeCharacter;

        if (activeCharacter === null) {
            /* It is no ones turn. */
            $("#notifArea").empty().wiki("Determining Turn");

            /* Decrement inits. */
            pp.forEach((char) => {
                char.init -= .25;
            });
            ep.forEach((char) => {
                char.init -= .25;
            });

            
            drawCombat(null);
	        
            await waitFor(10); 
            return processTurns(pp, ep);

        } else if (State.temporary.pp.includes(activeCharacter)) {
            /* Player Turn */
            $("#notifArea").empty().wiki("Player Turn");

            drawCombat("pp");
            
            /* The player will processTurns() after clicking a button. No need to do it here. */
            return;
        } else if (State.temporary.ep.includes(activeCharacter)) {
            /* Enemy Turn */
            $("#notifArea").empty().wiki("Enemy Turn");

            drawCombat("ep");

            /* TODO: Enemy AI here */
            await waitFor(600);

            /* setup.COM.attackCalculations(ep[0].attacks[0], State.temporary.ep[0], State.temporary.pp); */ 

            /* DELETE ONCE AI IS REAL */
            activeCharacter.init += activeCharacter.attacks[1].initRecovery;
            pp[0].health -= 3;
            return $("#combatZone").wiki(Story.get("Combat_Zone").processText());
        } else {
            console.error("Is it no one's turn, but turn didn't equal null.");
            console.error(activeCharacter);
        }
    };

    processTurns(State.temporary.pp, State.temporary.ep);
}
<</script>>



:: Combat_Zone_Main [.combat .helper nostats]
/* TODO: Make these into a grid, which will auto format the griditems depending on the number of enemies. There should be a max of 5 enemies, I think, with 3 frontline and 2 backline. I'm not adding in frontline/backline mechanics yet, but it would be good to consider them, as that can add a dimensionality to my combat. */
/* There should also be a place for notifications with the flash ui. */

<combatZoneGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. */
    <<if _ep[0]>>
    <griditem id="gitemA">
        _ep[0].name
        <br>Hp:
        <progress class="healthBar" sc-eval:value="_ep[0].health" sc-eval:max="_ep[0].healthMax"></progress>
    </griditem>
    <</if>>

    <<if _ep[1]>>
    <griditem id="gitemB">
        _ep[1].name
        <br>Hp:
        <progress class="healthBar" sc-eval:value="_ep[1].health" sc-eval:max="_ep[1].healthMax"></progress>
    </griditem>
    <</if>>

    <<if _ep[2]>>
    <griditem id="gitemC">
        _ep[2].name
        <br>Hp:
        <progress class="healthBar" sc-eval:value="_ep[2].health" sc-eval:max="_ep[2].healthMax"></progress>
    </griditem>
    <</if>>

    <<if _ep[3]>>
    <griditem id="gitemD">
        _ep[3].name
        <br>Hp:
        <progress class="healthBar" sc-eval:value="_ep[3].health" sc-eval:max="_ep[3].healthMax"></progress>
    </griditem>
    <</if>>

    <<if _ep[4]>>
    <griditem id="gitemE">
        _ep[4].name
        <br>Hp:
        <progress class="healthBar" sc-eval:value="_ep[4].health" sc-eval:max="_ep[4].healthMax"></progress>
    </griditem>
    <</if>>
</combatZoneGrid>



:: Player_Options [.combat .helper nostats]
$pc_name
<br>HP: _pc.health / _pc.healthMax
<br>
<progress class="healthBar" sc-eval:value="_pc.health" sc-eval:max="_pc.healthMax"></progress>
<br>
/* TODO: Show the statisitical details of all attacks. */
/* TODO: Incorporate menu into something like https://www.cssscript.com/multi-level-radial-tree-menu/ or https://codepen.io/onlyveen/pen/MVaLoX*/
<<if _turn === _pc>>
    <<for _attack range _pc.attacks>>
        <<capture _attack>>
            <<ibutton _attack.name "#PlayerAttack">>
                /* TODO for target selection: Make attack button disabled, pop up more buttons asking which enemy to attack, or otherwise make it obvious that the enemies can be clicked on to be attacked. Also show a "back" button to undo attack. */

                /* If ep[0] targetable, #gitemA class += targetable */
                /* What if there are no targetable enemies? I think we should just diable the button with a notice. */
                <<script>>
                    setup.COM.attackCalculations(State.temporary.attack, State.temporary.pc, State.temporary.ep);
                    State.temporary.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <</capture>>
    <</for>>
<<else>>
    <<for _attack range _pc.attacks>>
        <<capture _attack>>
            <<disable>><<ibutton _attack.name "#PlayerAttack">><</ibutton>><</disable>>
        <</capture>>
    <</for>>
<</if>>
