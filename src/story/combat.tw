:: Combat_Overlord [@combatoverlord .combat nostats]
/**
 * This passage will only be run once, and will be the predominant 
 * passage until combat is over. This will allow us to keep _vars 
 * until we are done with the combat. 
 */

/* NYI: These should be handled as story variables before combat begins. */
<<set _win to "victorypassagename">>
<<set _lose to "losepassagename">>

<<script>>
    /** 
     * Because Player is barely functional and only used here for 
     * testing and development purposes, the whole initialization of 
     * _pp is a mess. 
     *
     * In the future, initialization of pp will be done properly.
     */
    /* NYI: Initialize Player Party */
    State.temporary.pp = [];
    for (let uninitPlayer of State.variables.pp) {
        State.temporary.pp.push(new setup.COM.Combatant(uninitPlayer));
    }

    /* Initialize Enemy Party */
    State.temporary.ep = [];
    for (let uninitEnemy of State.variables.ep) {
        State.temporary.ep.push(new setup.COM.Combatant(setup.COM.monsters[uninitEnemy]));
    }

    /* Add the locations of each character to their obj. */
    for (let i = 0; i < State.temporary.ep.length; i++) {
        switch (i) {
            case 0:
                State.temporary.ep[i].location = "enemyA";
                break;
            case 1:
                State.temporary.ep[i].location = "enemyB";
                break;
            case 2:
                State.temporary.ep[i].location = "enemyC";
                break;
            case 3:
                State.temporary.ep[i].location = "enemyD";
                break;
            case 4:
                State.temporary.ep[i].location = "enemyE";
                break;
        }
    }
    for (let i = 0; i < State.temporary.pp.length; i++) {
        switch (i) {
            case 0:
                State.temporary.pp[i].location = "playerA";
                break;
            case 1:
                State.temporary.pp[i].location = "playerB";
                break;
            case 2:
                State.temporary.pp[i].location = "playerC";
                break;
            case 3:
                State.temporary.pp[i].location = "playerD";
                break;
        }
    }

    $(document).one(":passagedisplay", function() {
        /* On passage completion, initialize. */
        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
        /* And scroll into view. */
        document.getElementById("chapterheader").scrollIntoView();
    });
<</script>>

/* NYI: Show the statisitical details of all Combatants. */
/* NYI: Show the statisitical details of all Player Attacks. */
/* <span id="combatInfoZone"></span> */

/* This is effectively the enemies' side of the "field". */
<span id="combatZone"></span>

/* This is the dividing bar between the enemies and the player. */
<span id="notifArea"></span>

/**
 * This is effectively the player's side of the "field". 
 * It lets the player pick attacks, use items, etc, etc.
 */
<span id="playerOptions"></span>



:: Combat_Zone [.combat .helper nostats]
/**
 * The Combat_Zone passage dictates the logic of the combat. It 
 * iterates through "ticks" of combat, which decrement all character's
 * initialization as well as update their Canvas information. It also 
 * determines whose turn it is.
 * 
 * Its contents are run at the very beginning of combat, and at the 
 * end of every Player or Enemy turn.
 */
<<script>>
/**
 * Determine which characters should have their Canvas information 
 * updated.
 * 
 * Redraw ::Player_Attacks.
 */
function drawCombat() {
    /**
     * We reprocess this so that if it is the player's turn, they can
     * make an attack. Or alternatively, if it is not their turn, 
     * their attack icons are disabled.
     */
    $("#playerAttacks").empty().wiki(Story.get("Player_Attacks").processText());

    /**
     * Determine which characters should have their Canvas information 
     * updated.
     */
    if (State.temporary.ep[0]) {
        $('#gitemA progress.healthBar').attr({
            value: State.temporary.ep[0].health,
            max: State.temporary.ep[0].healthMax
        });
        updateCanvas(State.temporary.ep[0], "enemy", $('canvas.initBar#enemyA'));
    }
    if (State.temporary.ep[1]) {
        $('#gitemB progress.healthBar').attr({
            value: State.temporary.ep[1].health,
            max: State.temporary.ep[1].healthMax
        });
        updateCanvas(State.temporary.ep[1], "enemy", $('canvas.initBar#enemyB'));
    }
    if (State.temporary.ep[2]) {
        $('#gitemC progress.healthBar').attr({
            value: State.temporary.ep[2].health,
            max: State.temporary.ep[2].healthMax
        });
        updateCanvas(State.temporary.ep[2], "enemy", $('canvas.initBar#enemyC'));
    }
    if (State.temporary.ep[3]) {
        $('#gitemD progress.healthBar').attr({
            value: State.temporary.ep[3].health,
            max: State.temporary.ep[3].healthMax
        });
        updateCanvas(State.temporary.ep[3], "enemy", $('canvas.initBar#enemyD'));
    }
    if (State.temporary.ep[4]) {
        $('#gitemE progress.healthBar').attr({
            value: State.temporary.ep[4].health,
            max: State.temporary.ep[4].healthMax
        });
        updateCanvas(State.temporary.ep[4], "enemy", $('canvas.initBar#enemyE'));
    }
    if (State.temporary.pp[0]) {
        $('progress.healthBar#playerA').attr({
            value: State.temporary.pp[0].health,
            max: State.temporary.pp[0].healthMax
        });
        updateCanvas(State.temporary.pp[0], "player", $('canvas.initBar#playerA'));
    }
};

/**
 * Update the Canvas information of the given entity.
 * 
 * TODO: Since location information is now stored in char, we can get 
 * rid of the confusing ally parameter.
 */
function updateCanvas(char, ally, canvasElement) {
    /** 
     * jCanvas library documentation: 
     * https://projects.calebevans.me/jcanvas/docs/ 
     */
    canvasElement.clearCanvas();

    /* The left most starting position of the initbar line. */
    let horiBarXPos = 432;
    let hpBarXPos = horiBarXPos + 220;

    /**
     * HP Bar
     */
    /* "HP:" Text */
    canvasElement.drawText({
        fillStyle: '#FFFFFF',
        fontSize: 80,
        strokeWidth: 5,
        strokeStyle: '#FFFFFF',
        text: 'HP:',
        x: hpBarXPos - 160, 
        y: 78,
    });
    
    /* Outline */
    canvasElement.drawLine({
        strokeStyle: '#000000',
        strokeWidth: 80,
        rounded: true,
        x1: hpBarXPos - 20,
        y1: 78,
        x2: 2000,
        y2: 78,
    });
    /* Background */
    canvasElement.drawLine({
        strokeStyle: '#8C99A6',
        strokeWidth: 60,
        rounded: true,
        x1: hpBarXPos,
        y1: 78,
        x2: 1980,
        y2: 78,
    });
    /* Actual Heath Bar */
    if (char.health > 0) {
        canvasElement.drawLine({
            strokeStyle: '#AA0000',
            strokeWidth: 60,
            rounded: true,
            x1: hpBarXPos,
            y1: 78,
            x2: Math.max((char.health / char.healthMax * (1980 - hpBarXPos)) + hpBarXPos, hpBarXPos),
            y2: 78,
        });
    }

    /**
     * Init Bar
     */
    /* The rhombus. */
    let rhombusimg = "";
    let linecolor = "";
    if (ally === "player" && char.init <= 0) {
        /* Green rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon_pl.png";
        linecolor = "#2EFF23";
    } else if (ally === "enemy" && char.init <= 0) {
        /* Red rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon_en.png";
        linecolor = "#FF0000";
    } else {
        /* Yellow rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon.png";
        linecolor = "#FFFF00";
    }
    canvasElement.drawImage({
        source: rhombusimg,
        x: 192,
        y: 192,
        width: 384,
        height: 384,
    });

    /* The horizontal line. */
    canvasElement.drawLine({
        strokeStyle: linecolor,
        strokeWidth: 10,
        rounded: true,
        x1: horiBarXPos,
        y1: 256,
        x2: 2000,
        y2: 256,
    });

    /* Init indicator. */
    if (char.health > 0) {
        let xpos = Math.min(char.init * 8 + horiBarXPos, 2000);
        let iconimg = "";
        if (ally === "player") {
            /* Green indicator. */
            iconimg = "src/assets/img/png/init_icon_pl.png";
        } else if (ally === "enemy") {
            /* Red indicator. */
            iconimg = "src/assets/img/png/init_icon_en.png";
        }

        canvasElement.drawImage({
            source: iconimg,
            x: xpos,
            y: 320,
            width: 72,
            height: 88,
        });
    }
};

/**
 * This function is called every "tick". It decrements Combatants
 * inits and determines whose turn it is.
 */
async function processTurns(pp, ep) {
    function waitFor(ms) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve('')
            }, ms);
        });
    };

    let activeCharacter = null;

    /* Check if anyone has a turn available. */
    pp.forEach((char) => {
        if (char.init <= 0 && char.health > 0) {
            activeCharacter = char;
            return;
        }
    });
    if (activeCharacter === null) {
        ep.forEach((char) => {
            if (char.init <= 0 && char.health > 0) {
                activeCharacter = char;
                return;
            }
        });
    }

    /* So that we can use this value in other Twine places, notably, ::Player_Options. */
    State.temporary.turn = activeCharacter;

    if (activeCharacter === null) {
        /* It is no ones turn. */
        $("#notifArea").empty().wiki("Determining Turn");

        /* Decrement inits. */
        pp.forEach((char) => {
            char.init -= .25;
        });
        ep.forEach((char) => {
            char.init -= .25;
        });

        drawCombat();
        await waitFor(10);
        return processTurns(pp, ep);
    } else if (State.temporary.pp.includes(activeCharacter)) {
        /* Player Turn */
        $("#notifArea").empty().wiki("Player Turn");

        drawCombat();
        /* drawCombat() updates playerOptionsGrid, so the player can make a choice there. */

        /* The player will processTurns() after clicking a button. No need to do it here. */
        return;
    } else if (State.temporary.ep.includes(activeCharacter)) {
        /* Enemy Turn */
        $("#notifArea").empty().wiki("Enemy Turn");

        drawCombat();
        await waitFor(600);

        /* Enemy AI */
        let chosenAttack = setup.fns.ranItems(1, activeCharacter.attacks)[0];
        setup.COM.attackCalculations(chosenAttack, activeCharacter, State.temporary.pp);

        return $("#combatZone").wiki(Story.get("Combat_Zone").processText());
    } else {
        console.error(`Is it no one's turn, but it is ${activeCharacter.name}'s turn.`);
    }
};

$("#combatZone").empty().wiki(Story.get("Combat_Zone_Main").processText());
$("#playerOptions").empty().wiki(Story.get("Player_Options").processText());

/* REVIEW: I don't think these two temporary variables are really needed. */
State.temporary.pphealth = setup.fns.assignFieldOfObjectsToArray(State.temporary.pp, "health");
State.temporary.ephealth = setup.fns.assignFieldOfObjectsToArray(State.temporary.ep, "health");

if (setup.fns.allValuesTrue(State.temporary.pphealth, function(v) {
        return v <= 0
    })) {
    /* NYI: #notifArea displays <<ibutton>> with _lose */
    drawCombat();
    $("#notifArea").empty().wiki("YOU LOSE");
} else if (setup.fns.allValuesTrue(State.temporary.ephealth, function(v) {
        return v <= 0
    })) {
    /* NYI: #notifArea displays <<ibutton>> with _win */
    drawCombat();
    $("#notifArea").empty().wiki("YOU WIN");
} else {
    processTurns(State.temporary.pp, State.temporary.ep);
}
<</script>>



:: Combat_Zone_Main [.combat .helper nostats]
/**
 * The HTML elements of the enemies.
 */
<combatZoneGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. */
    <<if _ep[0]>>
    <griditem id="gitemA">
        _ep[0].name
        <canvas class="initBar" id="enemyA" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _ep[1]>>
    <griditem id="gitemB">
        _ep[1].name
        <canvas class="initBar" id="enemyB" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _ep[2]>>
    <griditem id="gitemC">
        _ep[2].name
        <canvas class="initBar" id="enemyC" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _ep[3]>>
    <griditem id="gitemD">
        _ep[3].name
        <canvas class="initBar" id="enemyD" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _ep[4]>>
    <griditem id="gitemE">
        _ep[4].name
        <canvas class="initBar" id="enemyE" width="2048" height="384"></canvas>
    </griditem>
    <</if>>
</combatZoneGrid>



:: Player_Options [.combat .helper nostats]
/**
 * The HTML elements of the player characters.
 *
 * DESIRED: Incorporate Attack menu into something like:
 *   https://www.cssscript.com/multi-level-radial-tree-menu/
 *   https://codepen.io/onlyveen/pen/MVaLoX
 */

/* Where the player attack elements currently show up. */
<span id="playerAttacks"></span>

/* HTML elements of the player characters. */
<playerOptionsGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. */
    <<if _pp[0]>>
    <griditem id="gitemA">
        _pp[0].name
        <canvas class="initBar" id="playerA" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _pp[1]>>
    <griditem id="gitemB">
        _pp[1].name
        <canvas class="initBar" id="playerB" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _pp[2]>>
    <griditem id="gitemC">
        _pp[2].name
        <canvas class="initBar" id="playerC" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _pp[3]>>
    <griditem id="gitemD">
        _pp[3].name
        <canvas class="initBar" id="playerD" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if _pp[4]>>
    <griditem id="gitemE">
        _pp[4].name
        <canvas class="initBar" id="playerE" width="2048" height="384"></canvas>
    </griditem>
    <</if>>
</playerOptionsGrid>



:: Player_Attacks [.combat .helper nostats]
/**
 * Determines the logic and HTML elements behind the player attacks.
 */
<<if _turn === _pp[0]>>
    <<for _attack range _pp[0].attacks>>
        <<capture _attack>>
            <<ibutton _attack.name "#PlayerAttack">>
                /* TODO for target selection: Make attack button disabled, pop up more buttons asking which enemy to attack, or otherwise make it obvious that the enemies can be clicked on to be attacked. Also show a "back" button to undo attack. */

                /* If ep[0] targetable, #gitemA class += targetable */
                /* What if there are no targetable enemies? I think we should just diable the button with a notice. */
                <<script>>
                    setup.COM.attackCalculations(State.temporary.attack, State.temporary.pp[0], State.temporary.ep);
                    State.temporary.pp[0].init += State.temporary.attack.initRecovery;
                    State.temporary.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <</capture>>
    <</for>>
<<else>>
    <<for _attack range _pp[0].attacks>>
        <<capture _attack>>
            <<disable>><<ibutton _attack.name "#PlayerAttack">><</ibutton>><</disable>>
        <</capture>>
    <</for>>
<</if>>
