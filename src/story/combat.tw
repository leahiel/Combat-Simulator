:: Combat_Overlord [@combatoverlord .combat nostats]
/**
 * This passage will only be run once, and will be the predominant 
 * passage until combat is over. This will allow us to keep _vars 
 * until we are done with the combat. 
 */

<<script>>
    /** 
     * Because Player is barely functional and only used here for 
     * testing and development purposes, the whole initialization of 
     * $ci.pp is a mess. 
     *
     * In the future, initialization of pp will be done properly.
     */
    
    $(document).one(":passagedisplay", function() {
        /* On passage completion, initialize. */
        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
        /* And scroll into view. */
        document.getElementById("chapterheader").scrollIntoView();
    });
<</script>>

/* NYI: Show the statisitical details of all Combatants. */
/* NYI: Show the statisitical details of all Player Attacks. */
/* <span id="combatInfoZone"></span> */

/* This is effectively the enemies' side of the "field". */
<span id="combatZone"></span>

/* This is the dividing bar between the enemies and the player. */
<span id="notifArea"></span>

/**
 * This is effectively the player's side of the "field". 
 * It lets the player pick attacks, use items, etc, etc.
 */
<span id="playerOptions"></span>



:: Combat_Zone [.combat .helper nostats]
/**
 * The Combat_Zone passage dictates the logic of the combat. It 
 * iterates through "ticks" of combat, which decrement all character's
 * initialization as well as update their Canvas information. It also 
 * determines whose turn it is.
 * 
 * Its contents are run at the very beginning of combat, and at the 
 * end of every Player or Enemy turn.
 */
<<script>>
/**
 * Determine which characters should have their Canvas information 
 * updated.
 * 
 * Redraw ::Player_Attacks.
 */
function drawCombat() {
    /**
     * We reprocess this so that if it is the player's turn, they can
     * make an attack. Or alternatively, if it is not their turn, 
     * their attack icons are disabled.
     */
    $("#playerAttacks").empty().wiki(Story.get("Player_Attacks").processText());

    /**
     * Determine which characters should have their Canvas information 
     * updated.
     * 
     * If so, update their canvas.
     */
    function determineIfCanvas(char) {
        if (char) {
            let status = "";
            if (char.location.includes("enemy")) {
                status = "enemy";
            } else if (char.location.includes("player")) {
                status = "player";
            }
            $(`#gittem${char.location.slice(-1)} progress.healthBar`).attr({
                value: char.health,
                max: char.healthMax
            });
            updateCanvas(char, status, $(`canvas.initBar#${char.location}`));
        }
    }

    determineIfCanvas(State.variables.ci.ep[0]);
    determineIfCanvas(State.variables.ci.ep[1]);
    determineIfCanvas(State.variables.ci.ep[2]);
    determineIfCanvas(State.variables.ci.ep[3]);
    determineIfCanvas(State.variables.ci.ep[4]);

    determineIfCanvas(State.variables.ci.pp[0]);
    determineIfCanvas(State.variables.ci.pp[1]);
    determineIfCanvas(State.variables.ci.pp[2]);
    determineIfCanvas(State.variables.ci.pp[3]);
};

/**
 * Update the Canvas information of the given entity.
 * 
 * TODO: Since location information is now stored in char, we can get 
 * rid of the confusing ally parameter.
 */
function updateCanvas(char, ally, canvasElement) {
    /** 
     * jCanvas library documentation: 
     * https://projects.calebevans.me/jcanvas/docs/ 
     */
    canvasElement.clearCanvas();

    /* The left most starting position of the initbar line. */
    let horiBarXPos = 432;
    let hpBarXPos = horiBarXPos + 220;

    /**
     * HP Bar
     */
    /* "HP:" Text */
    canvasElement.drawText({
        fillStyle: '#FFFFFF',
        fontSize: 80,
        strokeWidth: 5,
        strokeStyle: '#FFFFFF',
        text: 'HP:',
        x: hpBarXPos - 160, 
        y: 78,
    });
    
    /* Outline */
    canvasElement.drawLine({
        strokeStyle: '#000000',
        strokeWidth: 80,
        rounded: true,
        x1: hpBarXPos - 20,
        y1: 78,
        x2: 2000,
        y2: 78,
    });
    /* Background */
    canvasElement.drawLine({
        strokeStyle: '#8C99A6',
        strokeWidth: 60,
        rounded: true,
        x1: hpBarXPos,
        y1: 78,
        x2: 1980,
        y2: 78,
    });
    /* Actual Heath Bar */
    if (char.health > 0) {
        canvasElement.drawLine({
            strokeStyle: '#AA0000',
            strokeWidth: 60,
            rounded: true,
            x1: hpBarXPos,
            y1: 78,
            x2: Math.max((char.health / char.healthMax * (1980 - hpBarXPos)) + hpBarXPos, hpBarXPos),
            y2: 78,
        });
    }

    /**
     * Init Bar
     */
    /* The rhombus. */
    let rhombusimg = "";
    let linecolor = "";
    if (ally === "player" && char.init <= 0) {
        /* Green rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon_pl.png";
        linecolor = "#2EFF23";
    } else if (ally === "enemy" && char.init <= 0) {
        /* Red rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon_en.png";
        linecolor = "#FF0000";
    } else {
        /* Yellow rhombus and line. */
        rhombusimg = "src/assets/img/png/turn_icon.png";
        linecolor = "#FFFF00";
    }
    canvasElement.drawImage({
        source: rhombusimg,
        x: 192,
        y: 192,
        width: 384,
        height: 384,
    });

    /* The horizontal line. */
    canvasElement.drawLine({
        strokeStyle: linecolor,
        strokeWidth: 10,
        rounded: true,
        x1: horiBarXPos,
        y1: 256,
        x2: 2000,
        y2: 256,
    });

    /* Init indicator. */
    if (char.health > 0) {
        let xpos = Math.min(char.init * 8 + horiBarXPos, 2000);
        let iconimg = "";
        if (ally === "player") {
            /* Green indicator. */
            iconimg = "src/assets/img/png/init_icon_pl.png";
        } else if (ally === "enemy") {
            /* Red indicator. */
            iconimg = "src/assets/img/png/init_icon_en.png";
        }

        canvasElement.drawImage({
            source: iconimg,
            x: xpos,
            y: 320,
            width: 72,
            height: 88,
        });
    }
};

/**
 * This function is called every "tick". It decrements Combatants
 * inits and determines whose turn it is.
 */
async function processTurns(pp, ep) {
    function waitFor(ms) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve('')
            }, ms);
        });
    };

    let activeCharacter = null;

    /* Check if anyone has a turn available. */
    pp.forEach((char) => {
        if (char.init <= 0 && char.health > 0) {
            activeCharacter = char;
            return;
        }
    });
    if (activeCharacter === null) {
        ep.forEach((char) => {
            if (char.init <= 0 && char.health > 0) {
                activeCharacter = char;
                return;
            }
        });
    }

    /* So that we can use this value in other Twine places, notably, ::Player_Options. */
    State.variables.ci.turn = activeCharacter;

    if (activeCharacter === null) {
        /* It is no ones turn. */
        $("#notifArea").empty().wiki("Determining Turn");

        /* Decrement inits. */
        pp.forEach((char) => {
            char.init -= .25;
        });
        ep.forEach((char) => {
            char.init -= .25;
        });

        drawCombat();
        await waitFor(10);
        return processTurns(pp, ep);
    } else if (State.variables.ci.pp.includes(activeCharacter)) {
        /* Player Turn */
        $("#notifArea").empty().wiki("Player Turn");

        drawCombat();
        /* drawCombat() updates playerOptionsGrid, so the player can make a choice there. */

        /* The player will processTurns() after clicking a button. No need to do it here. */
        return;
    } else if (State.variables.ci.ep.includes(activeCharacter)) {
        /* Enemy Turn */
        $("#notifArea").empty().wiki("Enemy Turn");

        drawCombat();
        await waitFor(300);

        /* Enemy AI */
        setup.COM.attackRandomWithRandom(activeCharacter);

        return $("#combatZone").wiki(Story.get("Combat_Zone").processText());
    }
};

$("#combatZone").empty().wiki(Story.get("Combat_Zone_Main").processText());
$("#playerOptions").empty().wiki(Story.get("Player_Options").processText());

/* REVIEW: I don't think these two temporary variables are really needed. */
State.variables.ci.pphealth = setup.fns.assignFieldOfObjectsToArray(State.variables.ci.pp, "health");
State.variables.ci.ephealth = setup.fns.assignFieldOfObjectsToArray(State.variables.ci.ep, "health");

if (setup.fns.allValuesTrue(State.variables.ci.pphealth, function(v) {
        return v <= 0
    })) {
    drawCombat();
    /* Update notice area with wikified lose message. */
    $("#notifArea").empty().wiki(State.variables.ci.lose);
} else if (setup.fns.allValuesTrue(State.variables.ci.ephealth, function(v) {
        return v <= 0
    })) {
    drawCombat();
    /* Update notice area with wikified win message. */
    $("#notifArea").empty().wiki(State.variables.ci.win);
} else {
    processTurns(State.variables.ci.pp, State.variables.ci.ep);
}
<</script>>



:: Combat_Zone_Main [.combat .helper nostats]
/**
 * The HTML elements of the enemies.
 */
<combatZoneGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. It might now be possible though, since we only update Canvas element (as opposed to the Canvas itself) rarely. */
    <<if $ci.ep[0]>>
    <griditem id="gitemA">
        /* TODO: Add the name to the canvas instead so that I have total control over the thing. */
        $ci.ep[0].name
        <canvas class="initBar" id="enemyA" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[1]>>
    <griditem id="gitemB">
        $ci.ep[1].name
        <canvas class="initBar" id="enemyB" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[2]>>
    <griditem id="gitemC">
        $ci.ep[2].name
        <canvas class="initBar" id="enemyC" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[3]>>
    <griditem id="gitemD">
        $ci.ep[3].name
        <canvas class="initBar" id="enemyD" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[4]>>
    <griditem id="gitemE">
        $ci.ep[4].name
        <canvas class="initBar" id="enemyE" width="2048" height="384"></canvas>
    </griditem>
    <</if>>
</combatZoneGrid>



:: Player_Options [.combat .helper nostats]
/**
 * The HTML elements of the player characters.
 *
 * DESIRED: Incorporate Attack menu into something like:
 *   https://www.cssscript.com/multi-level-radial-tree-menu/
 *   https://codepen.io/onlyveen/pen/MVaLoX
 */

/* Where the player attack elements currently show up. */
<span id="playerAttacks"></span>

/* HTML elements of the player characters. */
<playerOptionsGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. */
    <<if $ci.pp[0]>>
    <griditem id="gitemA">
        $ci.pp[0].name
        <canvas class="initBar" id="playerA" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.pp[1]>>
    <griditem id="gitemB">
        $ci.pp[1].name
        <canvas class="initBar" id="playerB" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.pp[2]>>
    <griditem id="gitemC">
        $ci.pp[2].name
        <canvas class="initBar" id="playerC" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.pp[3]>>
    <griditem id="gitemD">
        $ci.pp[3].name
        <canvas class="initBar" id="playerD" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.pp[4]>>
    <griditem id="gitemE">
        $ci.pp[4].name
        <canvas class="initBar" id="playerE" width="2048" height="384"></canvas>
    </griditem>
    <</if>>
</playerOptionsGrid>



:: Player_Attacks [.combat .helper nostats]
/**
 * Determines the logic and HTML elements behind the player attacks.
 */
<<if $ci.turn === $ci.pp[0]>>
    <<for _attack range $ci.pp[0].attacks>>
        <<capture _attack>>
            <<set _viableTargets = setup.COM.assignViableTargets(_attack, $ci.pp[0])>>
            <<if _viableTargets.length === 0>>
                /* There are no viable targets, so disable the button. */
                <<disable>><<ibutton _attack.name "#PlayerAttack">><</ibutton>><</disable>>
            <<else>>
                <<ibutton _attack.name "#PlayerAttack">>
                    <<run $("#playerAttacks").empty().wiki(Story.get("Player_Attack_Targets").processText());>>
                <</ibutton>>
            <</if>>
        <</capture>>
    <</for>>
<<else>>
    <<for _attack range $ci.pp[0].attacks>>
        <<capture _attack>>
            <<disable>><<ibutton _attack.name "#PlayerAttack">><</ibutton>><</disable>>
        <</capture>>
    <</for>>
<</if>>



:: Player_Attack_Targets [.combat .helper nostats]
<<if _attack.targetType === "area">>
    /* Handle all. */
    <<if _attack.opponentTargetable && _attack.allyTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<ibutton "Hit Everyone" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.frontlineTargetable>>
            <<ibutton "Hit Both Frontlines" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.backlineTargetable>>
            <<ibutton "Hit Both Backlines" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <</if>>

    /* Handle enemies. */
    <<elseif _attack.opponentTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<ibutton "Hit All Enemies" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.frontlineTargetable>>
            <<ibutton "Hit Frontline" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.backlineTargetable>>
            <<ibutton "Hit Backline" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <</if>>

    /* Handle allies. */
    <<elseif _attack.allyTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<ibutton "Hit All Allies" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.frontlineTargetable>>
            <<ibutton "Hit Frontline Allies" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <<elseif _attack.backlineTargetable>>
            <<ibutton "Hit Backline Allies" "#AttackTarget">>
                <<script>>
                    let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.pp[0]);
                    setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], targets);
                    State.variables.ci.turn = null;
                    $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                <</script>>
            <</ibutton>>
        <</if>>
    <</if>>
<<else>>/* _attack.targetType = "single" */
    <<for _target range $ci.ep>>
        <<capture _target>>
            <<if _viableTargets.includes(_target) && _target.health > 0>>
                <<ibutton _target.name "#AttackTarget">>
                    <<script>>
                        setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], [State.temporary.target]);
                        State.variables.ci.turn = null;
                        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                    <</script>>
                <</ibutton>>
            <<else>>
                /* The target is not a viable target. */
                <<disable>><<ibutton _target.name "#AttackTarget">><</ibutton>><</disable>>
            <</if>>
        <</capture>>
    <</for>>
    <br>
    <<for _target range $ci.pp>>
        <<capture _target>>
            <<if _viableTargets.includes(_target)>>
                <<ibutton _target.name "#AttackTarget">>
                    <<script>>
                        setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.pp[0], State.temporary.target);
                        State.variables.ci.turn = null;
                        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                    <</script>>
                <</ibutton>>
            <<else>>
                /* The target is not a viable target. */
                <<disable>><<ibutton _target.name "#AttackTarget">><</ibutton>><</disable>>
            <</if>>
        <</capture>>
    <</for>>
<</if>>
<br>
/* Provide an option if the player wants to chose a different attack. */
<<ibutton "Back" "#BackAttack">>
    <<run $("#playerAttacks").empty().wiki(Story.get("Player_Attacks").processText());>>
<</ibutton>>
