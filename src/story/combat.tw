:: Combat_Overlord [@combatoverlord .combat nostats]
/**
 * This passage will only be run once, and will be the predominant 
 * passage until combat is over. This will allow us to keep _vars 
 * until we are done with the combat. 
 */
<<script>>
    $(document).one(":passagedisplay", function() {
        /* On passage completion, initialize. */
        $("#enemyZone").wiki(Story.get("Combat_Zone").processText());
        /* And scroll into view. */
        document.getElementById("passagetitleheader").scrollIntoView();
    });
<</script>>

/* NYI: Show the statisitical details of all Combatants. */
/* NYI: Show the statisitical details of all Player Attacks. */
/* <span id="combatInfoZone"></span> */

<grid id="MainCombatGrid">
    /* This is effectively the enemies' side of the "field". */
    <span id="enemyZone"></span>

    /* The "center field", if you will. */
    <span id="combatNotifications">DO I JUST NEED SOMETHING HERE</span>

    /**
    * This is effectively the player's side of the "field". 
    * It lets the player pick attacks, use items, etc, etc.
    */
    <span id="playerZone"></span>

    /* The options for the player. */
    <span id="targetsZone">
        <span id="notifArea"></span>

        <span id="playerAttacks"></span>

        <span id="backForward">
            <span id="back">Back</span>
            <span id="forward">Forward</span>
        </span>
    </span>
</grid>



:: Combat_Zone [.combat .helper nostats]
/**
 * The Combat_Zone passage dictates the logic of the combat. It 
 * iterates through "ticks" of combat, which decrement all character's
 * initialization as well as update their Canvas information. It also 
 * determines whose turn it is.
 * 
 * Its contents are run at the very beginning of combat, and at the 
 * end of every Player or Enemy turn.
 */
<<script>>
/**
 * This function is called every "tick". It decrements Combatants
 * inits and determines whose turn it is.
 */
async function processTurns(pp, ep) {
    function waitFor(ms) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve('')
            }, ms);
        });
    };

    /** Decrement init of the character, and apply buffs if applicable. */
    function decrementInits(char) {
        let initDecrementAmount = .25;
        char.init -= (initDecrementAmount * char.initDecrementModifier);

        for (let buff of char.buffs) {
            /* Decrement buff. If buff duration goes down a whole number, apply its effects. */
            let buffStart = Math.floor(buff.duration);
            buff.duration -= initDecrementAmount;
            let buffEnd = Math.floor(buff.duration);

            if (buffStart > buffEnd) {
                buff.perInit(char);
            }

            /* Remove expired buffs. */
            if (buff.duration < 0) {
                char.buffs = char.buffs.filter(function(value) { return value !== buff;});
                char.reform();
                setup.COM.determineIfCanvas(char);
            }
        }
    }

    let activeCharacter = null;

    /* Determine if all characters in pp are dead. */
    let ppdead = true;
    for (let char of State.variables.ci.pp) {
        if (char.health > 0) {
            ppdead = false;
            break;
        }
    }

    /* Determine if all characters in ep are dead. */
    let epdead = true;
    for (let char of State.variables.ci.ep) {
        if (char.health > 0) {
            epdead = false;
            break;
        }
    }

    if (ppdead) {
        setup.COM.drawCombat();
        /* Update notice area with wikified lose message. */
        $("#notifArea").empty().wiki(State.variables.ci.lose);
        State.variables.ci = undefined;
        return;
    } else if (epdead) {
        setup.COM.drawCombat();
        /* Update notice area with wikified win message. */
        $("#notifArea").empty().wiki(State.variables.ci.win);
        State.variables.ci = undefined;
        return;
    }

    /* If all of the frontline of a side are dead, allow frontline
    attacks to hit backline. */
    if (
        (!State.variables.ci.ep[0] || State.variables.ci.ep[0].health <= 0) && 
        (!State.variables.ci.ep[1] || State.variables.ci.ep[1].health <= 0) && 
        (!State.variables.ci.ep[2] || State.variables.ci.ep[2].health <= 0)
    ) {
        State.variables.ci.epbacklineTargetable = true
    }
    if (
        (!State.variables.ci.pp[0] || State.variables.ci.pp[0].health <= 0) && 
        (!State.variables.ci.pp[1] || State.variables.ci.pp[1].health <= 0)
    ) {
        State.variables.ci.ppbacklineTargetable = true
    }

    /* If all of the backline of a side are dead, allow backline
    attacks to hit frontline. */
    if (
        (!State.variables.ci.ep[3] || State.variables.ci.ep[3].health <= 0) && 
        (!State.variables.ci.ep[4] || State.variables.ci.ep[4].health <= 0)
    ) {
        State.variables.ci.epfrontlineTargetable = true
    }
    if (
        (!State.variables.ci.pp[2] || State.variables.ci.pp[2].health <= 0) && 
        (!State.variables.ci.pp[3] || State.variables.ci.pp[3].health <= 0)
    ) {
        State.variables.ci.ppfrontlineTargetable = true
    }

    /* Check if anyone has a turn available. */
    pp.forEach((char) => {
        if (char.init <= 0 && char.health > 0) {
            activeCharacter = char;
            return;
        }
    });
    if (activeCharacter === null) {
        ep.forEach((char) => {
            if (char.init <= 0 && char.health > 0) {
                activeCharacter = char;
                return;
            }
        });
    }

    /* So that we can use this value in other Twine places, notably, ::Player_Zone. */
    State.variables.ci.activeCharacter = activeCharacter;

    if (activeCharacter === null) {
        /* It is no ones turn. */
        $("#notifArea").empty().wiki("Determining Turn");

        /* Decrement inits. */
        pp.forEach((char) => {
            if (char.health > 0) {
                decrementInits(char);
            }
        });
        ep.forEach((char) => {
            if (char.health > 0) {
                decrementInits(char);
            }
        });

        setup.COM.drawCombat();
        await waitFor(20);
        return processTurns(pp, ep);
    } else if (State.variables.ci.pp.includes(activeCharacter)) {
        /* Player Turn */
        $("#notifArea").empty().wiki("Player Turn");

        setup.COM.drawCombat();
        /* setup.COM.drawCombat() updates #playerZone, so the player can make a choice there. */

        /* The player will processTurns() after clicking a button. No need to do it here. */
        return;
    } else if (State.variables.ci.ep.includes(activeCharacter)) {
        /* Enemy Turn */
        $("#notifArea").empty().wiki("Enemy Turn");

        setup.COM.drawCombat();
        await waitFor(500);

        /* Enemy AI */
        /* Not yet fully implemented, but this should call activeCharacter.ai() when complete.  */
        setup.COM.attackRandomWithRandom(activeCharacter);

        $("#enemyZone").wiki(Story.get("Combat_Zone").processText());
        return;
    }
};

$("#enemyZone").empty().wiki(Story.get("Combat_Zone_Main").processText());
$("#playerZone").empty().wiki(Story.get("Player_Zone").processText());

processTurns(State.variables.ci.pp, State.variables.ci.ep);
<</script>>



:: Combat_Zone_Main [.combat .helper nostats]
/**
 * The HTML elements of the enemies.
 */

/* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. It might now be possible though, since we only update Canvas element (as opposed to the Canvas itself) rarely. */
<<if $ci.ep[0]>>
    <griditem id="gitemA">
        /* TODO: Add the name to the canvas instead so that I have total control over the thing. */
        $ci.ep[0].name
        <canvas class="initBar" id="enemyA" width="2048" height="384"></canvas>
    </griditem>

    <<script>>
        setup.fns.displayToInfoScreenOnMouseover('#enemyZone griditem#gitemA', State.variables.ci.ep[0]);
    <</script>>
<</if>>

<<if $ci.ep[1]>>
    <griditem id="gitemB">
        $ci.ep[1].name
        <canvas class="initBar" id="enemyB" width="2048" height="384"></canvas>
    </griditem>

    <<script>>
        setup.fns.displayToInfoScreenOnMouseover('#enemyZone griditem#gitemB', State.variables.ci.ep[1]);
    <</script>>
<</if>>

<<if $ci.ep[2]>>
    <griditem id="gitemC">
        $ci.ep[2].name
        <canvas class="initBar" id="enemyC" width="2048" height="384"></canvas>
    </griditem>

    <<script>>
        setup.fns.displayToInfoScreenOnMouseover('#enemyZone griditem#gitemC', State.variables.ci.ep[2]);
    <</script>>
<</if>>

<<if $ci.ep[3]>>
    <griditem id="gitemD">
        $ci.ep[3].name
        <canvas class="initBar" id="enemyD" width="2048" height="384"></canvas>
    </griditem>

    <<script>>
        setup.fns.displayToInfoScreenOnMouseover('#enemyZone griditem#gitemD', State.variables.ci.ep[3]);
    <</script>>
<</if>>

<<if $ci.ep[4]>>
    <griditem id="gitemE">
        $ci.ep[4].name
        <canvas class="initBar" id="enemyE" width="2048" height="384"></canvas>
    </griditem>

    <<script>>
        setup.fns.displayToInfoScreenOnMouseover('#enemyZone griditem#gitemE', State.variables.ci.ep[4]);
    <</script>>
<</if>>
