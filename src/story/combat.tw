:: Combat_Overlord [@combatoverlord .combat nostats]
/**
 * This passage will only be run once, and will be the predominant 
 * passage until combat is over. This will allow us to keep _vars 
 * until we are done with the combat. 
 */

<<script>>
    $(document).one(":passagedisplay", function() {
        /* On passage completion, initialize. */
        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
        /* And scroll into view. */
        document.getElementById("chapterheader").scrollIntoView();
    });
<</script>>

/* NYI: Show the statisitical details of all Combatants. */
/* NYI: Show the statisitical details of all Player Attacks. */
/* <span id="combatInfoZone"></span> */

/* This is effectively the enemies' side of the "field". */
<span id="combatZone"></span>

<br>

/**
 * This is effectively the player's side of the "field". 
 * It lets the player pick attacks, use items, etc, etc.
 */
<span id="playerZone"></span>



:: Combat_Zone [.combat .helper nostats]
/**
 * The Combat_Zone passage dictates the logic of the combat. It 
 * iterates through "ticks" of combat, which decrement all character's
 * initialization as well as update their Canvas information. It also 
 * determines whose turn it is.
 * 
 * Its contents are run at the very beginning of combat, and at the 
 * end of every Player or Enemy turn.
 */
<<script>>
/**
 * This function is called every "tick". It decrements Combatants
 * inits and determines whose turn it is.
 */
async function processTurns(pp, ep) {
    function waitFor(ms) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve('')
            }, ms);
        });
    };

    /** Decrement init of the character, and apply buffs if applicable. */
    function decrementInits(char) {
        let initDecrementAmount = .25;
        char.init -= initDecrementAmount;

        for (let buff of char.buffs) {
            /* Decrement buff. If buff duration goes down a whole number, apply its effects. */
            let buffStart = Math.floor(buff.duration);
            buff.duration -= initDecrementAmount;
            let buffEnd = Math.floor(buff.duration);

            if (buffStart > buffEnd) {
                buff.perInit(char);
            }

            /* Remove expired buffs. */
            if (buff.duration < 0) {
                char.buffs = char.buffs.filter(function(value) { return value !== buff;});
                char.reform();
                setup.COM.determineIfCanvas(char);
            }
        }
    }

    let activeCharacter = null;

    /* If all of the frontline of a side are dead, allow frontline
    attacks to hit backline. */
    if (
        State.variables.ci.ep[0].health <= 0 && 
        State.variables.ci.ep[1].health <= 0 &&
        State.variables.ci.ep[2].health <= 0
    ) {
        State.variables.ci.epbacklineTargetable = true
    }
    if (
        State.variables.ci.pp[0].health <= 0 && 
        State.variables.ci.pp[1].health <= 0
    ) {
        State.variables.ci.ppbacklineTargetable = true
    }


    /* Check if anyone has a turn available. */
    pp.forEach((char) => {
        if (char.init <= 0 && char.health > 0) {
            activeCharacter = char;
            return;
        }
    });
    if (activeCharacter === null) {
        ep.forEach((char) => {
            if (char.init <= 0 && char.health > 0) {
                activeCharacter = char;
                return;
            }
        });
    }

    /* So that we can use this value in other Twine places, notably, ::Player_Zone. */
    State.variables.ci.activeCharacter = activeCharacter;

    if (activeCharacter === null) {
        /* It is no ones turn. */
        $("#notifArea").empty().wiki("Determining Turn");

        /* Decrement inits. */
        pp.forEach((char) => {
            if (char.health > 0) {
                decrementInits(char);
            }
        });
        ep.forEach((char) => {
            if (char.health > 0) {
                decrementInits(char);
            }
        });

        setup.COM.drawCombat();
        await waitFor(10);
        return processTurns(pp, ep);
    } else if (State.variables.ci.pp.includes(activeCharacter)) {
        /* Player Turn */
        $("#notifArea").empty().wiki("Player Turn");

        setup.COM.drawCombat();
        /* setup.COM.drawCombat() updates playerZoneGrid, so the player can make a choice there. */

        /* The player will processTurns() after clicking a button. No need to do it here. */
        return;
    } else if (State.variables.ci.ep.includes(activeCharacter)) {
        /* Enemy Turn */
        $("#notifArea").empty().wiki("Enemy Turn");

        setup.COM.drawCombat();
        await waitFor(300);

        /* Enemy AI */
        /* Not yet fully implemented, but this should call activeCharacter.ai() when complete.  */
        setup.COM.attackRandomWithRandom(activeCharacter);

        $("#combatZone").wiki(Story.get("Combat_Zone").processText());
        return;
    }
};

$("#combatZone").empty().wiki(Story.get("Combat_Zone_Main").processText());
$("#playerZone").empty().wiki(Story.get("Player_Zone").processText());

/* Determine if all characters in pp are dead. */
let ppdead = true;
for (let char of State.variables.ci.pp) {
    if (char.health > 0) {
        ppdead = false;
        break;
    }
}

/* Determine if all characters in ep are dead. */
let epdead = true;
for (let char of State.variables.ci.ep) {
    if (char.health > 0) {
        epdead = false;
        break;
    }
}

if (ppdead) {
    setup.COM.drawCombat();
    /* Update notice area with wikified lose message. */
    $("#notifArea").empty().wiki(State.variables.ci.lose);
} else if (epdead) {
    setup.COM.drawCombat();
    /* Update notice area with wikified win message. */
    $("#notifArea").empty().wiki(State.variables.ci.win);
} else {
    processTurns(State.variables.ci.pp, State.variables.ci.ep);
}
<</script>>



:: Combat_Zone_Main [.combat .helper nostats]
/**
 * The HTML elements of the enemies.
 */
<combatZoneGrid>
    /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. It might now be possible though, since we only update Canvas element (as opposed to the Canvas itself) rarely. */
    <<if $ci.ep[0]>>
    <griditem id="gitemA">
        /* TODO: Add the name to the canvas instead so that I have total control over the thing. */
        $ci.ep[0].name
        <canvas class="initBar" id="enemyA" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[1]>>
    <griditem id="gitemB">
        $ci.ep[1].name
        <canvas class="initBar" id="enemyB" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[2]>>
    <griditem id="gitemC">
        $ci.ep[2].name
        <canvas class="initBar" id="enemyC" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[3]>>
    <griditem id="gitemD">
        $ci.ep[3].name
        <canvas class="initBar" id="enemyD" width="2048" height="384"></canvas>
    </griditem>
    <</if>>

    <<if $ci.ep[4]>>
    <griditem id="gitemE">
        $ci.ep[4].name
        <canvas class="initBar" id="enemyE" width="2048" height="384"></canvas>
    </griditem>
    <</if>>
</combatZoneGrid>



:: Player_Zone [.combat .helper nostats]
/**
 * The HTML elements of the player characters.
 */

/* Where the player attack elements currently show up. */
<span id="playerAttacks"></span>

<playerCombatGrid>
/* HTML elements of the player characters. */
    <playerZoneGrid>
        /* NTS: I wanted to dynamically make these elements, but they aren't created fast enough to render properly. */
        <<if $ci.pp[0]>>
        <griditem id="gitemA">
            $ci.pp[0].name
            <canvas class="initBar" id="playerA" width="2048" height="384"></canvas>
        </griditem>
        <</if>>

        <<if $ci.pp[1]>>
        <griditem id="gitemB">
            $ci.pp[1].name
            <canvas class="initBar" id="playerB" width="2048" height="384"></canvas>
        </griditem>
        <</if>>

        <<if $ci.pp[2]>>
        <griditem id="gitemC">
            $ci.pp[2].name
            <canvas class="initBar" id="playerC" width="2048" height="384"></canvas>
        </griditem>
        <</if>>

        <<if $ci.pp[3]>>
        <griditem id="gitemD">
            $ci.pp[3].name
            <canvas class="initBar" id="playerD" width="2048" height="384"></canvas>
        </griditem>
        <</if>>

        <<if $ci.pp[4]>>
        <griditem id="gitemE">
            $ci.pp[4].name
            <canvas class="initBar" id="playerE" width="2048" height="384"></canvas>
        </griditem>
        <</if>>
    </playerZoneGrid>
    <playerOptionsGrid>
        /* This is the dividing bar between the enemies and the player. */
        <span id="notifArea"></span>

        /** TODO: Have 1 column in player options grid, and have a row item with three items in it. This will let us manipulate the number of items in rows and what not. Example:

        <griditem id="row1">
            <item id="item1">
            </item>
            <item id="item2">
            </item>
            <item id="item3">
            </item>
        </griditem>
         */

        <griditem id="gitem1">
        </griditem>
        <griditem id="gitem2">
        </griditem>
        <griditem id="gitem3">
        </griditem>

        <griditem id="gitem4">
        </griditem>
        <griditem id="gitem5">
        </griditem>
        <griditem id="gitem6">
        </griditem>

        <griditem id="gitem7">
        </griditem>
        <griditem id="gitem8">
        </griditem>
        <griditem id="gitem9">
        </griditem>

        <griditem id="gitem10">
        </griditem>
        <griditem id="gitem11">
        </griditem>
        <griditem id="gitem12">
        </griditem>

        <griditem id="gitem13">
        </griditem>
        <griditem id="gitem14">
        </griditem>
        <griditem id="gitem15">
        </griditem>
    </playerOptionsGrid>
</playerCombatgrid>


:: Player_Attacks [.combat .helper nostats]
/**
 * Determines the logic and HTML elements behind the player attacks.
 */

/* Clear the Player Options Grid */
<<script>>
    for (let i = 1; i <= 15; i++) {
        $(`playerOptionsGrid #gitem${i}`).empty();
    }
<</script>>

<<if $ci.pp.includes($ci.activeCharacter)>>
    <<for _int, _attack range $ci.activeCharacter.attacks>>
        <<capture _attack>>
            <<set _viableTargets = setup.COM.assignViableTargets(_attack, $ci.activeCharacter)>>
            <<if _viableTargets.length === 0>>
                /* There are no viable targets, so disable the button. */
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 1}`).wiki(`
                        <<disable>>
                            <<ibutton _attack.name "#PlayerAttack">>
                            <</ibutton>>
                        <</disable>>
                    `);
                <</script>>
            <<else>>
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 1}`).wiki(`
                        <<ibutton _attack.name "#PlayerAttack">>
                            <<run $("#playerAttacks").empty().wiki(Story.get("Player_Attack_Targets").processText());>>
                        <</ibutton>>
                    `);
                <</script>>
            <</if>>
        <</capture>>
    <</for>>
    <br>
<<else>>
    <br>
<</if>>



:: Player_Attack_Targets [.combat .helper nostats]
<<run setup.COM.clearPlayerOptions()>>

<<if _attack.targetType === "area">>
    /* Handle all. */
    <<if _attack.opponentTargetable && _attack.allyTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Everyone" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>

        <<elseif _attack.frontlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Both Frontlines" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>

        <<elseif _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Both Backlines" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>
        <</if>>

    /* Handle enemies. */
    <<elseif _attack.opponentTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit All Enemies" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>

        <<elseif _attack.frontlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Frontline" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>

        <<elseif _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Backline" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>
        <</if>>

    /* Handle allies. */
    <<elseif _attack.allyTargetable>>
        <<if _attack.frontlineTargetable && _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit All Allies" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>

        <<elseif _attack.frontlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Frontline Allies" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>
            
        <<elseif _attack.backlineTargetable>>
            <<script>>
                $(`playerOptionsGrid #gitem1`).wiki(`
                    <<ibutton "Hit Backline Allies" "#AttackTarget">>
                        <<script>>
                            let targets = setup.COM.assignViableTargets(State.temporary.attack, State.variables.ci.activeCharacter);
                            setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, targets);
                            State.variables.ci.activeCharacter = null;
                            $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                        <</script>>
                    <</ibutton>>
                `);
            <</script>>
            
        <</if>>
    <</if>>
<<else>>/* _attack.targetType = "single" */
    <<for _int, _target range $ci.ep>>
        <<capture _target>>
            <<if _viableTargets.includes(_target) && _target.health > 0>>
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 1}`).wiki(`
                        <<ibutton _target.name "#AttackTarget">>
                            <<script>>
                                setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, [State.temporary.target]);
                                State.variables.ci.activeCharacter = null;
                                $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                            <</script>>
                        <</ibutton>>
                    `);
                <</script>>
            <<else>>
                /* The target is not a viable target. */
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 1}`).wiki(`
                        <<disable>>
                            <<ibutton _target.name "#AttackTarget">>
                            <</ibutton>>
                        <</disable>>
                    `);
                <</script>>
                
            <</if>>
        <</capture>>
    <</for>>
    /* Handle Players */
    <<for _int, _target range $ci.pp>>
        <<capture _target>>
            <<if _viableTargets.includes(_target)>>
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 7}`).wiki(`
                        <<ibutton _target.name "#AttackTarget">>
                            <<script>>
                                setup.COM.attackCalculations(State.temporary.attack, State.variables.ci.activeCharacter, State.temporary.target);
                                State.variables.ci.activeCharacter = null;
                                $("#combatZone").wiki(Story.get("Combat_Zone").processText());
                            <</script>>
                        <</ibutton>>
                    `);
                <</script>>
                
            <<else>>
                /* The target is not a viable target. */
                <<script>>
                    $(`playerOptionsGrid #gitem${State.temporary.int + 7}`).wiki(`
                        <<disable>>
                            <<ibutton _target.name "#AttackTarget">>
                            <</ibutton>>
                        <</disable>>
                    `);
                <</script>>
            <</if>>
        <</capture>>
    <</for>>
<</if>>

/* Provide an option if the player wants to chose a different attack. */
<<script>>
    $(`playerOptionsGrid #gitem13`).wiki(`
        <<ibutton "Back" "#BackAttack">>
            <<run $("#playerAttacks").empty().wiki(Story.get("Player_Attacks").processText());>>
        <</ibutton>>
    `);
<</script>>
    