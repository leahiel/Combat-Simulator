:: Info_Description_Widget [widget .infoscreen .helper nostats]
<<widget EquipmentButtonInInfoScreen>>
    /** Normally I would write error the following error, but since this widget won't ever be used again, who cares:
     *  WriteError: _args[0] should be "weapon" || "armor" || "accessory" 
     */
     
    /* We capture because the <<but>> macro has its own _args. */
    <<set _captureArg to _args[0]>>
    <<set _tempstr to "equippableInfoScreen" + _args[0]>>
    
    <span class="equippableInfoScreen" @id="_tempstr">
        <<set _tempstr to _args[0] + "Here">>

        /* Create the item plate. */
        <span @id="_tempstr"></span>
        <<run $info.current.equippables[_captureArg].itemplate(`#${_tempstr}`);>>

        /* Create "Swap" and "Mod" buttons, disabling them if the player object doesn't exist. */
        <<capture _captureArg>>
            <<set _tempstr to _captureArg + "InfoScreenButtons">>
            <span @id="_tempstr">
                <<if $info.current === $tp1 || $info.current === $tp2>>
                    <<set _butname = "View Equip">>
                <<else>>
                    <<set _butname = "Equip">>
                <</if>>
                <<but _butname>>
                    <<script>>
                        let tempstr2;
                        let tempstr3;

                        switch (State.temporary.captureArg) {
                            case "weapon":
                                tempstr2 = "Weapons";
                                tempstr3 = "Weapon";
                                break;
                            case "armor":
                                tempstr2 = "Armors";
                                tempstr3 = "Armor";
                                break;
                            case "accessory":
                                tempstr2 = "Accessories";
                                tempstr3 = "Accessory";
                                break;
                        }

                        Dialog.setup(`${tempstr2}`, "dialogEquipmentSwap");
                        Dialog.wiki(`<<SlotMenuInfo ${State.temporary.captureArg}>>`);
                        Dialog.open();
                    <</script>>
                <</but>>
                <<if $info.current === $tp1 || $info.current === $tp2>>
                    <<set _butname = "View Mods">>
                <<else>>
                    <<set _butname = "Mods">>
                <</if>>
                <<if $info.current.equippables[_captureArg].type === "unequipped">>
                    <<disable>>
                        <<but _butname>>
                        <</but>>
                    <</disable>>
                <<else>>
                    <<but _butname>>
                        <<script>>
                            let tempstr2;
                            let tempstr3;

                            switch (State.temporary.captureArg) {
                                case "weapon":
                                    tempstr2 = "Weapons";
                                    tempstr3 = "Weapon";
                                    break;
                                case "armor":
                                    tempstr2 = "Armors";
                                    tempstr3 = "Armor";
                                    break;
                                case "accessory":
                                    tempstr2 = "Accessories";
                                    tempstr3 = "Accessory";
                                    break;
                            }

                            Dialog.setup(`${tempstr2} Mods`, "dialogEquipmentMod");
                            Dialog.wiki(`<<SlotModMenuInfo ${State.temporary.captureArg}>>`);
                            Dialog.open();
                        <</script>>
                    <</but>>

                <</if>>
            </span>
        <</capture>>
        /* Position "Swap" and "Mod" buttons. */
        <<script>>
            /* We do this because by the time the async runs, the State changes. */
            let tmpstr = State.temporary.captureArg;

            setup.fns.waitForElm(`span.itemPlate.${tmpstr}`).then(() => {
                setup.fns.waitForElm(`#${tmpstr}InfoScreenButtons`).then(() => {
                    $(`span.itemPlate.${tmpstr}`).append($(`#${tmpstr}InfoScreenButtons`));
                });
            });
        <</script>>
    </span>
<</widget>>



:: Slot_Menu_Info_Widget [widget .infoscreen .helper nostats]
<<widget SlotMenuInfo>>
    /** Normally I would write error the following error, but since this widget won't ever be used again, who cares:
     *  WriteError: _args[0] should be "weapon" || "armor" || "accessory" 
     */
    /* REVIEW: Do I want to add a button to this dialogue to switch to the appropriate mod menu dialogue? */

    /* Set tempvars. */
    <<set _captureArg to _args[0]>>
    <<set _listboxstr to "listbox-" + _args[0]>>
    <<script>>
        switch (State.temporary.args[0]) {
            case "weapon":
                State.temporary.strplural = "weapons";
                break;
            case "armor":
                State.temporary.strplural = "armors";
                break;
            case "accessory":
                State.temporary.strplural = "accessories";
                break;
        }
    <</script>>

    <<capture _captureArg _listboxstr>>
        /* Create listbox. */
        <<if $info.current === $tp1 || $info.current === $tp2>>
            <select @id="_listboxstr" class="macro-listbox" @name="_listboxstr" tabindex="0" autocomplete="off" size="2">
                <option value="0">$info.current.equippables[_captureArg].name</option>
            </select>
        <<else>>
            <select @id="_listboxstr" class="macro-listbox" @name="_listboxstr" tabindex="0" autocomplete="off" @size="$account.inventory[_strplural].length"> 
                <<for _i, _equippable range $account.inventory[_strplural]>>
                    /* NYI: add the `disabled` attribute if we don't own the equippable */
                    /* TODO: $account.inventory.weapons should probably be: [[weapon, bool], [weapon, bool]], where weapon as obj and bool is "obtained", which will allow disabled. */
                    <<if $info.current.equippables[_captureArg].name === _equippable.name>>
                        <<set _selectval to _i>>
                    <</if>>
                    <option @value="_i">_equippable.name</option>
                <</for>>
            </select>
        <</if>>
        
        /* So that we can add attack buttons to the swap menu. */
        <<if _captureArg === "weapon">>
            <span id="attackButtons"></span>
            <span id="attackInfoDescription" style="display: block"></span>
            <<run setup.fns.waitForElm("#attackButtons").then(() => {$.wiki(`<<replace '#attackButtons'>><<include "Show_Attacks">><</replace>>`)});>>
        <</if>>

        /* The place to show the character stats. */
        <span id="equipmentCharacterStats"><<print new setup.COM.Combatant($info.current).getInfo()>></span>

        <<script>>
            let st = State.temporary;
            let sv = State.variables;
            /* We do this because by the time the async runs, the State changes. */
            let tmpstr = st.listboxstr;
            let captureArg = st.captureArg;
            
            setup.fns.waitForElm(`#${tmpstr}`).then(()=> {
                /* Set the value of the listbox to the equipped item. */
                $(`#${tmpstr}`).val(st.selectval);

                /* Make listbox selection change related vars. */
                $(`#${tmpstr}`).change( function () {
                    sv.info.current.equippables[captureArg] = sv.account.inventory[st.strplural][$(`#${tmpstr}`).val()];

                    /* Update Info Screen Buttons with proper names. */
                    $('#infoScreenMiddleMenuButtons').empty().wiki(Story.get("Info_Description").processText());

                    /* Update character stats. */
                    $('#equipmentCharacterStats').empty().wiki(new setup.COM.Combatant(sv.info.current).getInfo());

                    /* Replace attacks with attacks from new weapon. */
                    if (captureArg === "weapon") {
                        $.wiki(`<<replace '#attackButtons'>><<include "Show_Attacks">><</replace>>`);
                    }
                });

                $(`#${tmpstr}`).on('mouseenter', 'option', function (elm) {
                    var $target = $(elm.target); 

                    if ($target.is('option')) { 
                        /* DESIRED: Show updated values to combatant in Green/Red */
                        /* Make sure the combatant info returns to normal when mouse leaves listbox. */
                    }
                });
            });
        <</script>>
    <</capture>>
<</widget>>



:: Slot_ModMenu_Info_Widget [widget .infoscreen .helper nostats]
<<widget SlotModMenuInfo>>
    /** Normally I would write error the following error, but since this widget won't ever be used again, who cares:
     *  WriteError: _args[0] should be "weapon" || "armor" || "accessory" 
     */
    /* REVIEW: Do I want to add a button to this dialogue to switch to the appropriate swap menu dialogue? */

    /* Set tempvars. */
    <<set _captureArg to _args[0]>>
    <<set _listboxstr to "listbox-" + _captureArg + "Mods">>
    <<capture _captureArg>>
        <<script>>
            let st = State.temporary;
            let svaim = State.variables.account.inventory.mods;
            /* We do this because by the time the async runs, the State changes. */
            let captureArg = st.captureArg;

            switch (captureArg) {
                case "weapon":
                    st.strcap = "Weapon";
                    break;
                case "armor":
                    st.strcap = "Armor";
                    break;
                case "accessory":
                    st.strcap = "Accessory";
                    break;
            }

            /* Temp array with all the mods that have the slot type. */
            st.viableModList = [setup.COM.affixes.unequippedMod];
            for (let mod in svaim) {
                if (svaim[mod].type === captureArg) {
                    st.viableModList.push(svaim[mod]);
                }
            }

            /* TODO: If mod is already on an equipment, remove it. */
            /* NYI: So the account mod list should be something like [[mod, bool], [mod, bool]]. Or maybe the bool is in the item itself. */
        <</script>>

        /* Create a listbox element for every modslot, populate it with viable mods array. */
        <<set _selectvalmod to []>>

        /* Create listbox. */
        <<if $info.current === $tp1 || $info.current === $tp2>>
            <<for _i = 0; _i < $info.current.equippables[_captureArg].modslots; _i++>>
                Slot _i:
                <select @id="_listboxstr" class="macro-listbox" @name="_listboxstr" tabindex="0" autocomplete="off" size="2">
                    <option value="0">$info.current.equippables[_captureArg].mods[_i].name</option>
                </select>
                <br>
            <</for>>
        <<else>>
            <<for _i = 0; _i < $info.current.equippables[_captureArg].modslots; _i++>>
                Slot _i:
                <select @id="_listboxstr" @class="_listboxstr" @name="_listboxstr" tabindex="0" @boxnum=_i @size="$info.current.equippables[_captureArg].modslots">
                    <<for _j, _mod range _viableModList>>
                        <<if _mod.name === $info.current.equippables[_captureArg].mods[_i].name>>
                            <<set _selectvalmod[_i] to _j>>
                        <</if>>
                        <option @value=_j>_mod.name t._mod.tier</option>
                    <</for>>
                </select>
                <br>
            <</for>>
        <</if>>

        /* Make listbox selection change related vars. */
        <<script>>
            let st = State.temporary;
            let svice = State.variables.info.current.equippables;
            let captureArg = st.captureArg;
            let selectvalmod = st.selectvalmod;
            let viableModList = st.viableModList;

            /* Wait for all .listbox-slotMods to be done */
            setup.fns.waitForNumberOfElm(`.${st.listboxstr}`, svice[captureArg].modslots).then(() => {
                /* Set the value of the listboxes to the equipped item. */
                for (i = 0; i < svice[captureArg].modslots; i++) {
                    $(`#listbox-${captureArg}Mods[boxnum="${i}"]`).val(selectvalmod[i]);
                }

                $(`.${st.listboxstr}`).change( function (elm) {
                    /* Change the modslot's mod to the updated mod. */
                    svice[captureArg].mods[$(this).attr("boxnum")] = viableModList[$(this).val()];
                    /* Update the Equippable */
                    svice[captureArg].applyMods();

                    /* Reload this dialogue so that viableModList is updated. */
                    Dialog.setup(`${st.strcap} Mods`, "dialogEquipmentMod");
                    Dialog.wiki(`<<SlotModMenuInfo ${captureArg}>>`);
                    Dialog.open();
                });
            });
        <</script>>
    <</capture>>
<</widget>>



:: Show_Attacks [.infoscreen .helper nostats]
<span id="infoScreenAttacks"></span>
<<run setup.fns.waitForElm("#infoScreenAttacks").then((elm) => {$(elm).wiki(Story.get("Show_Attacks_Helper").processText())});>>


:: Show_Attacks_Helper [.infoscreen .helper nostats]
<<for _int, _attack range $info.current.equippables.weapon.attacks>>
    <<capture _attack>>
        <<run $("#infoScreenAttacks").wiki(Story.get("Player_Attack_Disabled").processText());>>
        <<run setup.fns.displayToInfoScreenOnMouseover(`#PlayerAttack${_int + 1}`, _attack, $info.current);>>
    <</capture>>
<</for>>



:: Players_Info [.infoscreen .helper nostats]
/** Show these buttons during combat. 
 * REVIEW: Disable instead? 
 */
<<script>>
if (!tags().includes(".combat")) {
    $('#infoScreenBottomMenuButtons').empty();
    let solstr = "";
    solstr += `<<PlayerInfo $pc>>`;           
    solstr += `<<PlayerInfo $pp>>`;           
    solstr += `<<PlayerInfo $tp1>>`;           
    solstr += `<<PlayerInfo $tp2>>`;           

    $('#infoScreenBottomMenuButtons').wiki(solstr);
} else {
    $('#infoScreenMiddleMenuButtons').empty()
}
<</script>>



:: Player_Info_Widget [widget .infoscreen .helper nostats]
<<widget PlayerInfo>>
    /** Normally I would write error the following error, but since this widget won't ever be used again, who cares:
     *  WriteError: _args[0] should be $pc || $pp || $tp1 || $tp2 
     */

    /* Create the character button that brings up that character's equipment. */
    <<if _args[0]>>
        <<but _args[0].name class "bottomInfoButton">>
            <<set $info.current = _args[0]>>
            <<run $('#infoScreenMiddleMenuButtons').empty().wiki(Story.get("Info_Description").processText());>>
        <</but>>
    <<else>>
        <<disable>>
            <<but "Char Not Present" class "bottomInfoButton">>
            <</but>>
        <</disable>>
    <</if>>
<</widget>>



:: Info_Description [.infoscreen .helper nostats]
<<if $info.current === null>>
    Info Screen Description.
<<else>>
    <<EquipmentButtonInInfoScreen "weapon">>
    <<EquipmentButtonInInfoScreen "armor">>
    <<EquipmentButtonInInfoScreen "accessory">>

    <<run $('#infoScreenBottomMenuButtons').empty().wiki(Story.get("Info_Button_Back").processText());>>
<</if>>



:: Info_Button_Back [.infoscreen .helper nostats]
<<but "Back" id "infoBack" class "bottomInfoButton">>
    <<set $info.current = null>>
    <<run $('#infoScreenMiddleMenuButtons').empty()>>
    <<run $('#infoScreenBottomMenuButtons').empty().wiki(Story.get("Players_Info").processText())>>
<</but>>
